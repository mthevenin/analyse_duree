{
  "hash": "8c0fe30180f3dd7c8f86b99e0f875285",
  "result": {
    "markdown": "\n# **SAS**\n\n::: callout-note\n\n* Ce pas à pas n'a pas fait de mise à jour depuis 3 ans. \n* Pour les personnes de l'Ined, à noter que SAS Studio (serveur margaux) a été mis à jour, et qu'il est maintenant possible d'estimer les RMST avec `proc lifetest`.\n- Le document n'a pas été compilé en PDF, seule cette version html est disponible.\n\n:::\n\n\n\n**Remarque: Sélection des outputs**\n\nSelon le type d'analyse la totalité des outputs ne seront pas reproduits (```ods include``` ou ```ods exclude``` pour la sélection). Un problème spécifique s'observe pour le tableau des estimateurs de Kaplan-Meier qui est particulièrement illisible en présence d'un nombre important d'observations censurées.\n\nExemple pour ```proc lifetest```: noms des outputs récupérés dans la log\n\n::: {.cell}\n\n```{.r .cell-code}\nOutput Added:\n-------------\nName:       ProductLimitEstimates\nLabel:      Product-Limit Estimates\nTemplate:   Stat.Lifetest.ProductLimitEstimates\nPath:       Lifetest.Stratum1.ProductLimitEstimates\n-------------\n\nOutput Added:\n-------------\nName:       Quartiles\nLabel:      Quartiles of the Survival Distribution\nTemplate:   Stat.Lifetest.Quartiles\nPath:       Lifetest.Stratum1.TimeSummary.Quartiles\n-------------\n\nOutput Added:\n-------------\nName:       Means\nLabel:      Mean\nTemplate:   Stat.Lifetest.Means\nPath:       Lifetest.Stratum1.TimeSummary.Means\n-------------\n\nOutput Added:\n-------------\nName:       SurvivalPlot\nLabel:      Survival Curve\nTemplate:   Stat.Lifetest.Graphics.ProductLimitSurvival\nPath:       Lifetest.Stratum1.SurvivalPlot\n-------------\n\nOutput Added:\n-------------\nName:       CensoredSummary\nLabel:      Censored Summary\nTemplate:   Stat.Lifetest.CensoredSummary\nPath:       Lifetest.CensoredSummary\n```\n:::\n\n\nUtiliser de préférence le nom figurant dans la ligne **path:** (si comparaison de deux strates, le nom figurant dans la ligne **name** est identique).  \n\n\n\n## Analyse non paramétrique\n\n\n### Méthode actuarielle\n\nAvec une longueur d'intervalle fixe égale à 30 jours.\n\nLa durée médiane est donnée par la colonne **résidual median time**. Sur la première ligne, il s'agit de la durée médiane sur toutes les personnes exposées au risque. Dans les lignes suivante, cette durée médiane est recalculée pour les personnes restant exposées au risque dans chaque intervalle.\n\n\n\n::: {.cell}\n\n```{.r .cell-code}\nproc lifetest data=trans method=lifetable width=30;\ntime stime*died(0);run;\n```\n:::\n\n\n![](sas/1a.PNG)\n\n![](sas/1b.PNG)\n\n![](sas/1c.png)\n\n\n### Méthode Kaplan-Meier\n\nLe tableau des estimateurs ne sera pas reporté (voir intro du document).  \nPour récupérer ces estimateurs, on peut les récupérer via l'instruction output et les exporter, par exemple, dans un tableur.\n\n\n::: {.cell}\n\n```{.r .cell-code}\nods exclude Lifetest.Stratum1.ProductLimitEstimates;\nproc lifetest data=trans;\ntime stime*died(0); run;\n```\n:::\n\n\n![](sas/2a.PNG)\n\n![](sas/2b.png)\n\n![](sas/2c.PNG)\n\n**Warning sur la durée moyenne reportée**\nSauf exception ne pas interpréter le tableau donnant la durée moyenne. Se reporter à l'estimation des RMST plus bas.\n\n**Comparaison des fonctions de survie**\n\n*Tests du log rank* \n\n\n::: {.cell}\n\n```{.r .cell-code}\nods exclude Lifetest.Stratum1.ProductLimitEstimates Lifetest.Stratum2.ProductLimitEstimates ;\nproc lifetest data=trans;\ntime stime*died(0);\nstrata surgery / test=all;\nrun;\n```\n:::\n\n\n\n![](sas/3a.png)\n\n![](sas/3b.PNG)\n\n![](sas/3c.PNG)\n\n![](sas/3d.PNG)\n\n\n*Comparaison des RMST*\n\nDisponible avec le dernier module stat de Sas base (Sas-Stat 15.1 novembre 2018).  \n\n\n::: {.cell}\n\n```{.r .cell-code}\nods exclude Lifetest.Stratum1.ProductLimitEstimates;\nproc lifetest data=trans rmst plots=(rmst);\ntime stime*died(0);\nstrata surgery; run;\n```\n:::\n\n\n![](sas/4.PNG)\n\n\n## Modèle de Cox\n\n### Estimation du modèle\n\n\n::: {.cell}\n\n```{.r .cell-code}\nproc phreg data=trans;\nmodel stime*died(0) = year age surgery ;\nrun;\n```\n:::\n\n\n![](sas/5a.PNG)\n\n\n\n\n### Tests de l'hypothèse PH\n\n#### Test de Grambsch Therneau\n\nDemande au moins l'avant dernière version de Sas/Stat (2016?).  \n\nLe test est exécuté directement dans l'instruction ```phreg``` (ajouter ```zph```). L'option global permet de récupérer le résultat du test omnibus (attention rejette facilement $H_0$ - hypothèse PH respectée - lorsque le nombre de degrés de liberté est élevé).  \n\n\n::: {.cell}\n\n```{.r .cell-code}\nods select PHReg.zphTest;\nproc phreg data=trans zph(global noplot);\nmodel stime*died(0) = year age surgery ;\nrun;\n```\n:::\n\n\n![](sas/5b.PNG)\n\nPar défaut SAS utilise la transformation $f(t)=t$ (idem Stata). Pour obtenir l'option par défaut de R $f(t) = 1 - KM(t)$:\n\n\n::: {.cell}\n\n```{.r .cell-code}\nods select PHReg.zphTest;\nproc phreg data=trans zph(global noplot transform=km);\nmodel stime*died(0) = year age surgery ;\nrun;\n```\n:::\n\n\n![](sas/5c.PNG)\n\n#### Interaction avec la durée\n\n**Estimation d'un modèle avec indicatrices**  \nLa covariable doit être sous forme d'indicatrice (binaire: (0,1)). Ce qui est le cas ici avec la variable *surgery*.  \n\nExemple avec une covariable X à 3 modalités codée 1,2,3.  \n\nEstimation du modèle de Cox avec l'instruction ```class``` (ref: X=1)\n\n::: {.cell}\n\n```{.r .cell-code}\nproc phreg data=base;\nclass X(ref=\"1\");\nmodel variable_dur*variable_cens(0) = X; run;\n```\n:::\n\n\nEstimation du modèle de Cox avec indicatrices\n\n::: {.cell}\n\n```{.r .cell-code}\ndata base; set base;\nX1 = X=1;\nX2 = X=2;\nX3 = X=3; run;\n\nproc phreg data=base;\nmodel variable_dur*variable_cens(0) = X2 X3; run;\n```\n:::\n\n\n\nLa variable d'intéraction ($surgeryt = surgery\\times stime$) est générée, le temps de l'estimation après l'instruction ```model```.  \n\n\n::: {.cell}\n\n```{.r .cell-code}\nods select PHReg.ParameterEstimates;\nproc phreg data=trans ;\nmodel stime*died(0) = year age surgery surgeryt ;\nsurgeryt = surgery*stime;\nrun;\n```\n:::\n\n\n![](sas/5d.PNG)\n\n### Variable dynamique\n\n**Warning: opération en 'aveugle'**\n\nContrairement à R et Stata, la base n’a pas à être splittée, on ne peut pas vérifier si la variable dynamique a été correctement créée. La variable dynamique, qui peut être appréhendée comme une variable en intéraction avec la durée, est générée après l’instruction `model`.   \n<br>\nIci la tvc prendra la valeur 1 lorsque *stime>wait*, 0 sinon.\n\n\n::: {.cell}\n\n```{.r .cell-code}\nods select PHReg.ParameterEstimates;\nproc phreg data=trans;\nmodel stime*died(0) = year age surgery tvc ;\ntvc = transplant=1 and stime>=wait;\nrun;\n```\n:::\n\n\n![](sas/6.PNG)\n\n## Modèle à temps discret\n\n### Mise en forme\n\nOn utilise une boucle pour répliquer les lignes sur la valeur de la durée. La nouvelle variable de durée (t) sous forme de compteur est générée automatiquement. \n\n\n::: {.cell}\n\n```{.r .cell-code}\ndata td; set trans; \ndo t=1 to mois; \n     output; \n     end; run;\n     \ndata td; set td;\nif t<mois then died=0;\nt2=t*t;\nt3=t2*t; run;\n```\n:::\n\n\n### Durée continue\n\n\n*Estimation du modèle*\n\n\n::: {.cell}\n\n```{.r .cell-code}\nods select Logistic.FitStatistics;\nproc logistic data=td;\nmodel died(ref=\"0\") = t t2 t3 year age surgery  ; run;\n```\n:::\n\n\n![](sas/7a.PNG)\n\n### Durée discrète\n\nPour l'exemple on va regrouper la durée par ses quartiles.\nPour chaque individu, on conserve seulement une observation dans chaque quartile.\n\n\n::: {.cell}\n\n```{.r .cell-code}\nproc rank data=td out=td2 groups=4;\nvar t;\nranks tq4;\nrun;\n\ndata td2; set td2;\nid2=put(id, 3.);\ntq42=put(tq4, 1.);\ng=id2 || tq42; run;\n\nproc sort data=td2; by id tq4; run;\n\ndata td2; set td2;\nby g;\nif LAST.g; run;\n```\n:::\n\n\n*Estimation*\n\n\n::: {.cell}\n\n```{.r .cell-code}\nproc logistic data=td2;\nclass tq4 / param=ref;\nmodel died(ref=\"0\") = tq4 year age surgery; run;\n```\n:::\n\n\n![](sas/7c.PNG)\n\n![](sas/7d.PNG)\n\n# Modèles paramétrique\n\nOn utilise la procédure proc **`lifereg`** et on indique le type de distribution\n\n\n::: {.cell}\n\n```{.r .cell-code}\nproc lifereg data=trans;\nmodel stime*died(0) = year age surgery /D=WEIBULL;\nrun;\n```\n:::\n\n\n![](sas/8a.PNG)\n\n![](sas/8b.PNG)\n\n\n::: {.cell}\n\n```{.r .cell-code}\nproc lifereg data=trans;\nmodel stime*died(0) = year age surgery /D=LLOGISTIC;\nrun;\n```\n:::\n\n\n![](sas/8c.PNG)\n\n![](sas/8d.PNG)\n\n## Risques concurrents\n\n### Non paramétrique\n\nOn indique en option la cause d'intérêt avec **`eventcode=valeur`** , les autres étant considérées commes des risques concurrents. \n\n\n::: {.cell}\n\n```{.r .cell-code}\nproc lifetest data=trans plots=CIF;\ntime stime*compet(0) / eventcode=1; run;\n```\n:::\n\n\n\n![](sas/9a.PNG)\n\n![](sas/9b.PNG)\n\n![](sas/9c.png)\n\nPour récupérer le test de Gray, on utilise l'instruction `strata`.\n\n\n::: {.cell}\n\n```{.r .cell-code}\nproc lifetest data=trans plots=CIF;\ntime stime*compet(0) / eventcode=1\nstrata surgery; run;\n```\n:::\n\n\n![](sas/9f.PNG)\n\n![](sas/9g.PNG)\n\n### Modèle logistique multinomial à durée discrète\n\n\n::: {.cell}\n\n```{.r .cell-code}\ndata td; set trans; \ndo t=1 to mois; \n     output; \n     end; \nrun;\ndata td; set td;\nif t<mois then compet=0;\nt2=t*t\nrun;\n```\n:::\n\n::: {.cell}\n\n```{.r .cell-code}\nproc logistic data=td;\nmodel compet(ref=\"0\") = t t2 year age surgery / link=glogit;\nrun;\n```\n:::\n\n\n![](sas/9i.PNG)\n\n![](sas/9j.PNG)\n\n\n",
    "supporting": [
      "15-Sas_files"
    ],
    "filters": [
      "rmarkdown/pagebreak.lua"
    ],
    "includes": {},
    "engineDependencies": {},
    "preserve": {},
    "postProcess": true
  }
}