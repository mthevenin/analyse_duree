{
  "hash": "d202d43b52845129faeb007f0a8abe6b",
  "result": {
    "markdown": "---\nfilters:\n  - lightbox\nlightbox: auto\n---\n\n::: callout-note\n\n- Le document qui suit n'est qu'un programme fait il y a 3-4 ans. Utilisant très peu Python, je n'ai pas documenté les fonctions, plus ou moins obsures, qui ont été utilisées.\n- L'exécution a été réalisé le noyau `python3` de jupyter.\n- Le document n'a pas été compilé en PDF, seule cette version html est disponible.\n\n:::\n\n\n# **Python**\n\n\nDeux paquets d'analyse: principalement `lifelines` (km, cox, aft...) et `statsmodels``` (estimation logit en temps discret, kaplan-Meier, Cox).\n\n\nLe package ```statsmodels``` est également ne mesure d'estimer des courbes de séjour de type Kaplan-Meier et des modèles à risque proportionnel de Cox. Le package ```lifelines``` couvre la quasi totalité des méthodes standards, à l'exception des les risques concurrents.  \n\n::: {.cell execution_count=1}\n``` {.python .cell-code}\nimport numpy  as np\nimport pandas as pd\nimport patsy  as pt\nimport lifelines as lf\nimport matplotlib.pyplot as plt\nimport statsmodels as sm\n```\n:::\n\n\nChargement de la base\n\n::: {.cell execution_count=2}\n``` {.python .cell-code}\ntrans = pd.read_csv(\"https://raw.githubusercontent.com/mthevenin/analyse_duree/master/bases/transplantation.csv\")\n\ntrans.head(10)\ntrans.info()\n```\n\n::: {.cell-output .cell-output-stdout}\n```\n<class 'pandas.core.frame.DataFrame'>\nRangeIndex: 103 entries, 0 to 102\nData columns (total 10 columns):\n #   Column      Non-Null Count  Dtype\n---  ------      --------------  -----\n 0   id          103 non-null    int64\n 1   year        103 non-null    int64\n 2   age         103 non-null    int64\n 3   died        103 non-null    int64\n 4   stime       103 non-null    int64\n 5   surgery     103 non-null    int64\n 6   transplant  103 non-null    int64\n 7   wait        103 non-null    int64\n 8   mois        103 non-null    int64\n 9   compet      103 non-null    int64\ndtypes: int64(10)\nmemory usage: 8.2 KB\n```\n:::\n:::\n\n\n## Package lifelines\n\n**Documentation**: <https://lifelines.readthedocs.io/en/latest/>\n\n\n### Non Paramétrique: Kaplan Meier\n\n**Estimateur KM et durée médiane**\n\n::: {.cell execution_count=3}\n``` {.python .cell-code}\nT = trans['stime']\nE = trans['died']\n\n\nfrom lifelines import KaplanMeierFitter\nkmf = KaplanMeierFitter()\nkmf.fit(T,E)\nprint(kmf.survival_function_)\na = \"DUREE MEDIANE:\"\nb = kmf.median_survival_time_\nprint(a,b)\n```\n\n::: {.cell-output .cell-output-stdout}\n```\n          KM_estimate\ntimeline             \n0.0          1.000000\n1.0          0.990291\n2.0          0.961165\n3.0          0.932039\n5.0          0.912621\n...               ...\n1400.0       0.151912\n1407.0       0.151912\n1571.0       0.151912\n1586.0       0.151912\n1799.0       0.151912\n\n[89 rows x 1 columns]\nDUREE MEDIANE: 100.0\n```\n:::\n:::\n\n\n::: {.cell execution_count=4}\n``` {.python .cell-code}\nkmf.plot()\n```\n\n::: {.cell-output .cell-output-display execution_count=4}\n```\n<AxesSubplot: xlabel='timeline'>\n```\n:::\n\n::: {.cell-output .cell-output-display}\n![](16-Python_files/figure-pdf/cell-5-output-2.pdf){fig-pos='H'}\n:::\n:::\n\n\n**Comparaison des fonctions de survie**\n\n::: {.cell execution_count=5}\n``` {.python .cell-code}\nax = plt.subplot(111)\nkmf = KaplanMeierFitter()\nfor name, grouped_df in trans.groupby('surgery'):\n    kmf.fit(grouped_df['stime'], grouped_df['died'], label=name)\n    kmf.plot(ax=ax)\n```\n\n::: {.cell-output .cell-output-display}\n![](16-Python_files/figure-pdf/cell-6-output-1.pdf){fig-pos='H'}\n:::\n:::\n\n\n::: {.cell execution_count=6}\n``` {.python .cell-code}\nfrom lifelines.statistics import multivariate_logrank_test\nresults = multivariate_logrank_test(trans['stime'], trans['surgery'], trans['died'])\nresults.print_summary()\n```\n\n::: {.cell-output .cell-output-display}\n```{=tex}\n\\begin{tabular}{lrrr}\n & test_statistic & p & -log2(p) \\\\\n0 & 6.59 & 0.01 & 6.61 \\\\\n\\end{tabular}\n```\n:::\n:::\n\n\n## Semi paramétrique: Cox\n\n### Estimation\n\n::: {.cell execution_count=7}\n``` {.python .cell-code}\nmodel = 'year + age + C(surgery) -1'\nX = pt.dmatrix(model, trans, return_type='dataframe')\ndesign_info = X.design_info\nYX = X.join(trans[['stime','died']])\nYX.drop(['C(surgery)[0]'], axis=1, inplace=True)\nYX.head()\n\n\nfrom lifelines import CoxPHFitter\ncph = CoxPHFitter()\ncph.fit(YX, duration_col='stime', event_col='died')\ncph.print_summary()\ncph.plot()\n```\n\n::: {.cell-output .cell-output-display}\n```{=tex}\n\\begin{tabular}{lrrrrrrrrrrr}\n & coef & exp(coef) & se(coef) & coef lower 95% & coef upper 95% & exp(coef) lower 95% & exp(coef) upper 95% & cmp to & z & p & -log2(p) \\\\\ncovariate &  &  &  &  &  &  &  &  &  &  &  \\\\\nC(surgery)[1] & -0.99 & 0.37 & 0.44 & -1.84 & -0.13 & 0.16 & 0.88 & 0.00 & -2.26 & 0.02 & 5.40 \\\\\nyear & -0.12 & 0.89 & 0.07 & -0.25 & 0.01 & 0.78 & 1.01 & 0.00 & -1.78 & 0.08 & 3.72 \\\\\nage & 0.03 & 1.03 & 0.01 & 0.00 & 0.06 & 1.00 & 1.06 & 0.00 & 2.19 & 0.03 & 5.12 \\\\\n\\end{tabular}\n```\n:::\n\n::: {.cell-output .cell-output-display execution_count=7}\n```\n<AxesSubplot: xlabel='log(HR) (95% CI)'>\n```\n:::\n\n::: {.cell-output .cell-output-display}\n![](16-Python_files/figure-pdf/cell-8-output-3.pdf){fig-pos='H'}\n:::\n:::\n\n\n### Tests hypothèse PH\n\n**Test PH: Schoenfeld Méthode 1**\n\n::: {.cell execution_count=8}\n``` {.python .cell-code}\ncph.check_assumptions(YX,p_value_threshold=0.05)\n```\n\n::: {.cell-output .cell-output-stdout}\n```\nThe ``p_value_threshold`` is set at 0.05. Even under the null hypothesis of no violations, some\ncovariates will be below the threshold by chance. This is compounded when there are many covariates.\nSimilarly, when there are lots of observations, even minor deviances from the proportional hazard\nassumption will be flagged.\n\nWith that in mind, it's best to use a combination of statistical tests and visual tests to determine\nthe most serious violations. Produce visual plots using ``check_assumptions(..., show_plots=True)``\nand looking for non-constant lines. See link [A] below for a full example.\n\n```\n:::\n\n::: {.cell-output .cell-output-display}\n```{=tex}\n\\begin{tabular}{llrrr}\n &  & test_statistic & p & -log2(p) \\\\\n\\multirow[c]{2}{*}{C(surgery)[1]} & km & 4.01 & 0.05 & 4.47 \\\\\n & rank & 3.74 & 0.05 & 4.23 \\\\\n\\multirow[c]{2}{*}{age} & km & 1.18 & 0.28 & 1.86 \\\\\n & rank & 1.06 & 0.30 & 1.72 \\\\\n\\multirow[c]{2}{*}{year} & km & 2.07 & 0.15 & 2.73 \\\\\n & rank & 2.08 & 0.15 & 2.75 \\\\\n\\end{tabular}\n```\n:::\n\n::: {.cell-output .cell-output-stdout}\n```\n\n\n1. Variable 'C(surgery)[1]' failed the non-proportional test: p-value is 0.0452.\n\n   Advice: with so few unique values (only 2), you can include `strata=['C(surgery)[1]', ...]` in\nthe call in `.fit`. See documentation in link [E] below.\n\n---\n[A]  https://lifelines.readthedocs.io/en/latest/jupyter_notebooks/Proportional%20hazard%20assumption.html\n[B]  https://lifelines.readthedocs.io/en/latest/jupyter_notebooks/Proportional%20hazard%20assumption.html#Bin-variable-and-stratify-on-it\n[C]  https://lifelines.readthedocs.io/en/latest/jupyter_notebooks/Proportional%20hazard%20assumption.html#Introduce-time-varying-covariates\n[D]  https://lifelines.readthedocs.io/en/latest/jupyter_notebooks/Proportional%20hazard%20assumption.html#Modify-the-functional-form\n[E]  https://lifelines.readthedocs.io/en/latest/jupyter_notebooks/Proportional%20hazard%20assumption.html#Stratification\n\n```\n:::\n\n::: {.cell-output .cell-output-display execution_count=8}\n```\n[]\n```\n:::\n:::\n\n\n**Test PH: Schoenfeld Méthode 2**\n\n::: {.cell execution_count=9}\n``` {.python .cell-code}\nfrom lifelines.statistics import  proportional_hazard_test \nzph = proportional_hazard_test(cph, YX, time_transform='all')\nzph.print_summary()\n```\n\n::: {.cell-output .cell-output-display}\n```{=tex}\n\\begin{tabular}{llrrr}\n &  & test_statistic & p & -log2(p) \\\\\n\\multirow[c]{4}{*}{C(surgery)[1]} & identity & 5.54 & 0.02 & 5.75 \\\\\n & km & 4.01 & 0.05 & 4.47 \\\\\n & log & 3.69 & 0.05 & 4.19 \\\\\n & rank & 3.74 & 0.05 & 4.23 \\\\\n\\multirow[c]{4}{*}{age} & identity & 1.61 & 0.20 & 2.29 \\\\\n & km & 1.18 & 0.28 & 1.86 \\\\\n & log & 0.61 & 0.44 & 1.20 \\\\\n & rank & 1.06 & 0.30 & 1.72 \\\\\n\\multirow[c]{4}{*}{year} & identity & 0.80 & 0.37 & 1.43 \\\\\n & km & 2.07 & 0.15 & 2.73 \\\\\n & log & 1.34 & 0.25 & 2.02 \\\\\n & rank & 2.08 & 0.15 & 2.75 \\\\\n\\end{tabular}\n```\n:::\n:::\n\n\n**Test PH: intéraction**\n\n::: {.cell execution_count=10}\n``` {.python .cell-code}\nfrom lifelines.utils import to_episodic_format\nfrom lifelines import CoxTimeVaryingFitter\n```\n:::\n\n\n*Transformation de la base YX*\n\n::: {.cell execution_count=11}\n``` {.python .cell-code}\nlong = to_episodic_format(YX, duration_col='stime', event_col='died')\n```\n:::\n\n\n*Création de la variable d'intéraction*\n\n::: {.cell execution_count=12}\n``` {.python .cell-code}\nlong['surgery_t'] = long['C(surgery)[1]'] * long['stop']\n```\n:::\n\n\n*Estimation*\n\n::: {.cell execution_count=13}\n``` {.python .cell-code}\nctv = CoxTimeVaryingFitter()\nctv.fit(long,\n        id_col='id',\n        event_col='died',\n        start_col='start',\n        stop_col='stop',)\nctv.print_summary(4)\n```\n\n::: {.cell-output .cell-output-display}\n```{=tex}\n\\begin{tabular}{lrrrrrrrrrrr}\n & coef & exp(coef) & se(coef) & coef lower 95% & coef upper 95% & exp(coef) lower 95% & exp(coef) upper 95% & cmp to & z & p & -log2(p) \\\\\ncovariate &  &  &  &  &  &  &  &  &  &  &  \\\\\nC(surgery)[1] & -1.7547 & 0.1730 & 0.6743 & -3.0764 & -0.4331 & 0.0461 & 0.6485 & 0.0000 & -2.6022 & 0.0093 & 6.7542 \\\\\nage & 0.0289 & 1.0293 & 0.0134 & 0.0025 & 0.0552 & 1.0025 & 1.0568 & 0.0000 & 2.1479 & 0.0317 & 4.9785 \\\\\nyear & -0.1231 & 0.8842 & 0.0668 & -0.2541 & 0.0079 & 0.7756 & 1.0080 & 0.0000 & -1.8415 & 0.0656 & 3.9312 \\\\\nsurgery_t & 0.0022 & 1.0022 & 0.0011 & 0.0001 & 0.0044 & 1.0001 & 1.0044 & 0.0000 & 2.0239 & 0.0430 & 4.5402 \\\\\n\\end{tabular}\n```\n:::\n:::\n\n\n### Variable dynamique binaire\n\n## Modèle à temps discret\n\n### Ajustement continu\n\nModèle logistique estimé avec le paquet ```statsmodel```. La fonction ```to_episodic_format``` de ```lifelines``` permet de mettre en forme la base.  \nPour la  durée, on utilisera ici la variable **mois** (regroupement de stime par intervalle de 30 jours).\n\n::: {.cell execution_count=14}\n``` {.python .cell-code}\nimport statsmodels.formula.api as smf #type R formule => ce qu'on utilisera#\nimport statsmodels.api as sm #type python#\n```\n:::\n\n\n**Transformation de la base en format long**\n\n::: {.cell execution_count=15}\n``` {.python .cell-code}\ntd = pd.read_csv(\"https://raw.githubusercontent.com/mthevenin/analyse_duree/master/bases/transplantation.csv\")\ntd.drop(['id'], axis=1, inplace=True)\ntd['dur'] = td['mois']\ntd = to_episodic_format(td, duration_col='mois', event_col='died')\n```\n:::\n\n\n**Evaluation de l'ajustement avec des fonctions quadratiques**  \n\n::: {.cell execution_count=16}\n``` {.python .cell-code}\ntd['t2'] = td['stop']**2\ntd['t3'] = td['stop']**3\nfit1 = smf.glm(formula=  \"died ~ stop\", data=td, family=sm.families.Binomial()).fit()\nfit2 = smf.glm(formula=  \"died ~ stop + t2\", data=td, family=sm.families.Binomial()).fit()\nfit3 = smf.glm(formula=  \"died ~ stop + t2 + t3\", data=td, family=sm.families.Binomial()).fit()\n```\n:::\n\n\n**Comparaison des AIC**\n\n::: {.cell execution_count=17}\n``` {.python .cell-code}\nprint(\"AIC pour ajustement t1\")\nprint(fit1.aic)\nprint(\"AIC pour ajustement durée t1 + t2\")\nprint(fit2.aic)\nprint(\"AIC pour ajustement durée t1 + t2 + t3\")\nprint(fit3.aic)\n```\n\n::: {.cell-output .cell-output-stdout}\n```\nAIC pour ajustement t1\n504.5211512753311\nAIC pour ajustement durée t1 + t2\n492.11522432726747\nAIC pour ajustement durée t1 + t2 + t3\n486.50534103180416\n```\n:::\n:::\n\n\n**Estimation du modèle**\n\n::: {.cell execution_count=18}\n``` {.python .cell-code}\ntdfit = smf.glm(formula=  \"died ~ stop + t2 + t3 + year + age + surgery\", data=td, family=sm.families.Binomial()).fit()\ntdfit.summary()\n```\n\n::: {.cell-output .cell-output-display execution_count=18}\n```{=html}\n<table class=\"simpletable\">\n<caption>Generalized Linear Model Regression Results</caption>\n<tr>\n  <th>Dep. Variable:</th>         <td>died</td>       <th>  No. Observations:  </th>  <td>  1127</td> \n</tr>\n<tr>\n  <th>Model:</th>                  <td>GLM</td>       <th>  Df Residuals:      </th>  <td>  1120</td> \n</tr>\n<tr>\n  <th>Model Family:</th>        <td>Binomial</td>     <th>  Df Model:          </th>  <td>     6</td> \n</tr>\n<tr>\n  <th>Link Function:</th>         <td>Logit</td>      <th>  Scale:             </th> <td>  1.0000</td>\n</tr>\n<tr>\n  <th>Method:</th>                <td>IRLS</td>       <th>  Log-Likelihood:    </th> <td> -230.34</td>\n</tr>\n<tr>\n  <th>Date:</th>            <td>Thu, 10 Aug 2023</td> <th>  Deviance:          </th> <td>  460.67</td>\n</tr>\n<tr>\n  <th>Time:</th>                <td>14:13:48</td>     <th>  Pearson chi2:      </th> <td>1.30e+03</td>\n</tr>\n<tr>\n  <th>No. Iterations:</th>          <td>7</td>        <th>  Pseudo R-squ. (CS):</th>  <td>0.07732</td>\n</tr>\n<tr>\n  <th>Covariance Type:</th>     <td>nonrobust</td>    <th>                     </th>     <td> </td>   \n</tr>\n</table>\n<table class=\"simpletable\">\n<tr>\n      <td></td>         <th>coef</th>     <th>std err</th>      <th>z</th>      <th>P>|z|</th>  <th>[0.025</th>    <th>0.975]</th>  \n</tr>\n<tr>\n  <th>Intercept</th> <td>    7.0827</td> <td>    5.308</td> <td>    1.334</td> <td> 0.182</td> <td>   -3.320</td> <td>   17.486</td>\n</tr>\n<tr>\n  <th>stop</th>      <td>   -0.3721</td> <td>    0.082</td> <td>   -4.516</td> <td> 0.000</td> <td>   -0.534</td> <td>   -0.211</td>\n</tr>\n<tr>\n  <th>t2</th>        <td>    0.0142</td> <td>    0.005</td> <td>    2.835</td> <td> 0.005</td> <td>    0.004</td> <td>    0.024</td>\n</tr>\n<tr>\n  <th>t3</th>        <td>   -0.0002</td> <td> 7.85e-05</td> <td>   -2.113</td> <td> 0.035</td> <td>   -0.000</td> <td> -1.2e-05</td>\n</tr>\n<tr>\n  <th>year</th>      <td>   -0.1327</td> <td>    0.074</td> <td>   -1.798</td> <td> 0.072</td> <td>   -0.277</td> <td>    0.012</td>\n</tr>\n<tr>\n  <th>age</th>       <td>    0.0333</td> <td>    0.015</td> <td>    2.270</td> <td> 0.023</td> <td>    0.005</td> <td>    0.062</td>\n</tr>\n<tr>\n  <th>surgery</th>   <td>   -1.0109</td> <td>    0.449</td> <td>   -2.254</td> <td> 0.024</td> <td>   -1.890</td> <td>   -0.132</td>\n</tr>\n</table>\n```\n:::\n:::\n\n\n### Ajustement discret\n\n*Création des intervalles pour l'exemple (quantile de la durée en mois)*\n\n::: {.cell execution_count=19}\n``` {.python .cell-code}\ntd['ct4'] = pd.qcut(td['stop'],[0, .25, .5, .75, 1.]) \ntd['ct4'].value_counts(normalize=True)*100\ntd.ct4 = pd.Categorical(td.ct4)\ntd['ct4'] = td.ct4.cat.codes\n```\n:::\n\n\nPour chaque individu, on conserve une seule observation par intervalle.\n\n::: {.cell execution_count=20}\n``` {.python .cell-code}\ntd2 = td \ntd2['t'] = td2['ct4']\ntd2 = td2.sort_values(['id', 'stop'])\ntd2 =  td2.groupby(['id','ct4']).last()\n```\n:::\n\n\n**Estimation**\n\n::: {.cell execution_count=21}\n``` {.python .cell-code}\ntd2fit = smf.glm(formula=  \"died ~ C(t) +  year + age + surgery\", data=td2, family=sm.families.Binomial()).fit()\ntd2fit.summary()\n```\n\n::: {.cell-output .cell-output-display execution_count=21}\n```{=html}\n<table class=\"simpletable\">\n<caption>Generalized Linear Model Regression Results</caption>\n<tr>\n  <th>Dep. Variable:</th>         <td>died</td>       <th>  No. Observations:  </th>  <td>   197</td> \n</tr>\n<tr>\n  <th>Model:</th>                  <td>GLM</td>       <th>  Df Residuals:      </th>  <td>   190</td> \n</tr>\n<tr>\n  <th>Model Family:</th>        <td>Binomial</td>     <th>  Df Model:          </th>  <td>     6</td> \n</tr>\n<tr>\n  <th>Link Function:</th>         <td>Logit</td>      <th>  Scale:             </th> <td>  1.0000</td>\n</tr>\n<tr>\n  <th>Method:</th>                <td>IRLS</td>       <th>  Log-Likelihood:    </th> <td> -111.24</td>\n</tr>\n<tr>\n  <th>Date:</th>            <td>Thu, 10 Aug 2023</td> <th>  Deviance:          </th> <td>  222.48</td>\n</tr>\n<tr>\n  <th>Time:</th>                <td>14:13:49</td>     <th>  Pearson chi2:      </th>  <td>  221.</td> \n</tr>\n<tr>\n  <th>No. Iterations:</th>          <td>4</td>        <th>  Pseudo R-squ. (CS):</th>  <td>0.1808</td> \n</tr>\n<tr>\n  <th>Covariance Type:</th>     <td>nonrobust</td>    <th>                     </th>     <td> </td>   \n</tr>\n</table>\n<table class=\"simpletable\">\n<tr>\n      <td></td>         <th>coef</th>     <th>std err</th>      <th>z</th>      <th>P>|z|</th>  <th>[0.025</th>    <th>0.975]</th>  \n</tr>\n<tr>\n  <th>Intercept</th> <td>   12.4467</td> <td>    6.654</td> <td>    1.871</td> <td> 0.061</td> <td>   -0.594</td> <td>   25.488</td>\n</tr>\n<tr>\n  <th>C(t)[T.1]</th> <td>   -1.0334</td> <td>    0.419</td> <td>   -2.467</td> <td> 0.014</td> <td>   -1.854</td> <td>   -0.212</td>\n</tr>\n<tr>\n  <th>C(t)[T.2]</th> <td>   -1.6152</td> <td>    0.545</td> <td>   -2.965</td> <td> 0.003</td> <td>   -2.683</td> <td>   -0.547</td>\n</tr>\n<tr>\n  <th>C(t)[T.3]</th> <td>   -0.4789</td> <td>    0.599</td> <td>   -0.799</td> <td> 0.424</td> <td>   -1.654</td> <td>    0.696</td>\n</tr>\n<tr>\n  <th>year</th>      <td>   -0.2032</td> <td>    0.093</td> <td>   -2.181</td> <td> 0.029</td> <td>   -0.386</td> <td>   -0.021</td>\n</tr>\n<tr>\n  <th>age</th>       <td>    0.0469</td> <td>    0.018</td> <td>    2.533</td> <td> 0.011</td> <td>    0.011</td> <td>    0.083</td>\n</tr>\n<tr>\n  <th>surgery</th>   <td>   -1.1102</td> <td>    0.503</td> <td>   -2.209</td> <td> 0.027</td> <td>   -2.095</td> <td>   -0.125</td>\n</tr>\n</table>\n```\n:::\n:::\n\n\n## Modèle paramétrique de type AFT\n\n::: {.cell execution_count=22}\n``` {.python .cell-code}\nfrom lifelines import WeibullAFTFitter, LogLogisticAFTFitter\n```\n:::\n\n\n**Weibull**\n\n::: {.cell execution_count=23}\n``` {.python .cell-code}\naftw = WeibullAFTFitter()\naftw.fit(YX, duration_col='stime', event_col='died')\naftw.print_summary()\n```\n\n::: {.cell-output .cell-output-display}\n```{=tex}\n\\begin{tabular}{llrrrrrrrrrrr}\n &  & coef & exp(coef) & se(coef) & coef lower 95% & coef upper 95% & exp(coef) lower 95% & exp(coef) upper 95% & cmp to & z & p & -log2(p) \\\\\nparam & covariate &  &  &  &  &  &  &  &  &  &  &  \\\\\n\\multirow[c]{4}{*}{lambda_} & C(surgery)[1] & 1.97 & 7.17 & 0.78 & 0.44 & 3.50 & 1.56 & 33.05 & 0.00 & 2.53 & 0.01 & 6.45 \\\\\n & age & -0.06 & 0.94 & 0.02 & -0.11 & -0.01 & 0.90 & 0.99 & 0.00 & -2.49 & 0.01 & 6.28 \\\\\n & year & 0.16 & 1.18 & 0.12 & -0.08 & 0.40 & 0.93 & 1.49 & 0.00 & 1.33 & 0.18 & 2.44 \\\\\n & Intercept & -3.02 & 0.05 & 8.73 & -20.13 & 14.09 & 0.00 & 1310196.43 & 0.00 & -0.35 & 0.73 & 0.46 \\\\\nrho_ & Intercept & -0.59 & 0.56 & 0.09 & -0.77 & -0.41 & 0.46 & 0.67 & 0.00 & -6.33 & 0.00 & 31.93 \\\\\n\\end{tabular}\n```\n:::\n:::\n\n\n**Loglogistique**\n\n::: {.cell execution_count=24}\n``` {.python .cell-code}\naftl = LogLogisticAFTFitter()\naftl.fit(YX, duration_col='stime', event_col='died')\naftl.print_summary()\n```\n\n::: {.cell-output .cell-output-display}\n```{=tex}\n\\begin{tabular}{llrrrrrrrrrrr}\n &  & coef & exp(coef) & se(coef) & coef lower 95% & coef upper 95% & exp(coef) lower 95% & exp(coef) upper 95% & cmp to & z & p & -log2(p) \\\\\nparam & covariate &  &  &  &  &  &  &  &  &  &  &  \\\\\n\\multirow[c]{4}{*}{alpha_} & C(surgery)[1] & 2.27 & 9.70 & 0.69 & 0.92 & 3.63 & 2.50 & 37.56 & 0.00 & 3.29 & 0.00 & 9.95 \\\\\n & age & -0.04 & 0.96 & 0.02 & -0.08 & -0.00 & 0.92 & 1.00 & 0.00 & -2.01 & 0.04 & 4.48 \\\\\n & year & 0.24 & 1.27 & 0.12 & 0.01 & 0.47 & 1.01 & 1.60 & 0.00 & 2.06 & 0.04 & 4.66 \\\\\n & Intercept & -10.43 & 0.00 & 8.34 & -26.77 & 5.92 & 0.00 & 372.19 & 0.00 & -1.25 & 0.21 & 2.24 \\\\\nbeta_ & Intercept & -0.18 & 0.84 & 0.10 & -0.37 & 0.01 & 0.69 & 1.01 & 0.00 & -1.86 & 0.06 & 3.99 \\\\\n\\end{tabular}\n```\n:::\n:::\n\n\n# Package statsmodels\n\n\nhttps://www.statsmodels.org/dev/duration.html\n\nLe package permet d'estimer des fonction de séjour de type Kaplan-Meier et des modèles de Cox.\n\n## Kaplan-Meier\n\n::: {.cell execution_count=25}\n``` {.python .cell-code}\nkm = sm.SurvfuncRight(trans[\"stime\"], trans[\"died\"])\nkm.summary()\n```\n\n::: {.cell-output .cell-output-stderr}\n```\nC:\\Users\\thevenin_m\\AppData\\Roaming\\Python\\Python310\\site-packages\\IPython\\core\\formatters.py:343: FutureWarning:\n\nIn future versions `DataFrame.to_latex` is expected to utilise the base implementation of `Styler.to_latex` for formatting and rendering. The arguments signature may therefore change. It is recommended instead to use `DataFrame.style.to_latex` which also contains additional functionality.\n\n```\n:::\n\n::: {.cell-output .cell-output-display execution_count=25}\n```{=tex}\n\\begin{tabular}{lrrrr}\n\\toprule\n{} &  Surv prob &  Surv prob SE &  num at risk &  num events \\\\\nTime &            &               &              &             \\\\\n\\midrule\n1    &   0.990291 &      0.009661 &          103 &         1.0 \\\\\n2    &   0.961165 &      0.019037 &          102 &         3.0 \\\\\n3    &   0.932039 &      0.024799 &           99 &         3.0 \\\\\n5    &   0.912621 &      0.027825 &           96 &         2.0 \\\\\n6    &   0.893204 &      0.030432 &           94 &         2.0 \\\\\n8    &   0.883495 &      0.031612 &           92 &         1.0 \\\\\n9    &   0.873786 &      0.032722 &           91 &         1.0 \\\\\n12   &   0.863969 &      0.033795 &           89 &         1.0 \\\\\n16   &   0.834515 &      0.036672 &           88 &         3.0 \\\\\n17   &   0.824697 &      0.037532 &           85 &         1.0 \\\\\n18   &   0.814879 &      0.038348 &           84 &         1.0 \\\\\n21   &   0.795244 &      0.039858 &           83 &         2.0 \\\\\n28   &   0.785426 &      0.040557 &           81 &         1.0 \\\\\n30   &   0.775608 &      0.041222 &           80 &         1.0 \\\\\n32   &   0.765664 &      0.041875 &           78 &         1.0 \\\\\n35   &   0.755721 &      0.042496 &           77 &         1.0 \\\\\n36   &   0.745777 &      0.043084 &           76 &         1.0 \\\\\n37   &   0.735833 &      0.043642 &           75 &         1.0 \\\\\n39   &   0.725890 &      0.044171 &           74 &         1.0 \\\\\n40   &   0.705726 &      0.045186 &           72 &         2.0 \\\\\n43   &   0.695644 &      0.045652 &           70 &         1.0 \\\\\n45   &   0.685562 &      0.046090 &           69 &         1.0 \\\\\n50   &   0.675481 &      0.046502 &           68 &         1.0 \\\\\n51   &   0.665399 &      0.046888 &           67 &         1.0 \\\\\n53   &   0.655317 &      0.047249 &           66 &         1.0 \\\\\n58   &   0.645235 &      0.047585 &           65 &         1.0 \\\\\n61   &   0.635153 &      0.047898 &           64 &         1.0 \\\\\n66   &   0.625072 &      0.048187 &           63 &         1.0 \\\\\n68   &   0.604908 &      0.048696 &           62 &         2.0 \\\\\n69   &   0.594826 &      0.048917 &           60 &         1.0 \\\\\n72   &   0.574663 &      0.049293 &           59 &         2.0 \\\\\n77   &   0.564581 &      0.049448 &           57 &         1.0 \\\\\n78   &   0.554499 &      0.049583 &           56 &         1.0 \\\\\n80   &   0.544417 &      0.049695 &           55 &         1.0 \\\\\n81   &   0.534335 &      0.049787 &           54 &         1.0 \\\\\n85   &   0.524254 &      0.049858 &           53 &         1.0 \\\\\n90   &   0.514172 &      0.049908 &           52 &         1.0 \\\\\n96   &   0.504090 &      0.049938 &           51 &         1.0 \\\\\n100  &   0.494008 &      0.049946 &           50 &         1.0 \\\\\n102  &   0.483926 &      0.049934 &           49 &         1.0 \\\\\n110  &   0.473630 &      0.049922 &           47 &         1.0 \\\\\n149  &   0.463105 &      0.049910 &           45 &         1.0 \\\\\n153  &   0.452580 &      0.049873 &           44 &         1.0 \\\\\n165  &   0.442055 &      0.049811 &           43 &         1.0 \\\\\n186  &   0.431273 &      0.049750 &           41 &         1.0 \\\\\n188  &   0.420491 &      0.049660 &           40 &         1.0 \\\\\n207  &   0.409709 &      0.049544 &           39 &         1.0 \\\\\n219  &   0.398928 &      0.049399 &           38 &         1.0 \\\\\n263  &   0.388146 &      0.049227 &           37 &         1.0 \\\\\n285  &   0.365966 &      0.048848 &           35 &         2.0 \\\\\n308  &   0.354876 &      0.048610 &           33 &         1.0 \\\\\n334  &   0.343786 &      0.048340 &           32 &         1.0 \\\\\n340  &   0.332696 &      0.048036 &           31 &         1.0 \\\\\n342  &   0.321224 &      0.047730 &           29 &         1.0 \\\\\n583  &   0.305928 &      0.047845 &           21 &         1.0 \\\\\n675  &   0.287932 &      0.048297 &           17 &         1.0 \\\\\n733  &   0.269936 &      0.048515 &           16 &         1.0 \\\\\n852  &   0.250655 &      0.048731 &           14 &         1.0 \\\\\n979  &   0.227868 &      0.049341 &           11 &         1.0 \\\\\n995  &   0.205081 &      0.049390 &           10 &         1.0 \\\\\n1032 &   0.182295 &      0.048877 &            9 &         1.0 \\\\\n1386 &   0.151912 &      0.049277 &            6 &         1.0 \\\\\n\\bottomrule\n\\end{tabular}\n```\n:::\n:::\n\n\nLes test du log-rank sont disponibles avec la fonction ```survdiff``` (nom idem R). Au niveau graphique, la programmation semble un peu\nlourde et mériterait d'être simplifiée (donc non traitée).  \n\n**Comparaison de S(t) à partir des tests du log-rank**  \n\n<br>\nRésultat: (statistique de test, p-value)\n\n*Test non pondéré*\n\n::: {.cell execution_count=26}\n``` {.python .cell-code}\nsm.duration.survdiff(trans.stime, trans.died, trans.surgery)\n```\n\n::: {.cell-output .cell-output-display execution_count=26}\n```\n(6.5900123232343875, 0.010255246157888975)\n```\n:::\n:::\n\n\n*Breslow*\n\n::: {.cell execution_count=27}\n``` {.python .cell-code}\nsm.duration.survdiff(trans.stime, trans.died, trans.surgery, weight_type='gb')\n```\n\n::: {.cell-output .cell-output-display execution_count=27}\n```\n(8.989753779902493, 0.0027149757927903417)\n```\n:::\n:::\n\n\n*Tarone-Ware*\n\n::: {.cell execution_count=28}\n``` {.python .cell-code}\nsm.duration.survdiff(trans.stime, trans.died, trans.surgery, weight_type='tw')\n```\n\n::: {.cell-output .cell-output-display execution_count=28}\n```\n(8.462352726451392, 0.0036257256194570653)\n```\n:::\n:::\n\n\n## Modèle de Cox\n\n::: {.cell execution_count=29}\n``` {.python .cell-code}\nmod = smf.phreg(\"stime ~  year + age + surgery \",trans, status='died', ties=\"efron\")\nrslt = mod.fit()\nprint(rslt.summary())\n```\n\n::: {.cell-output .cell-output-stdout}\n```\n                       Results: PHReg\n=============================================================\nModel:                    PH Reg       Sample size:       103\nDependent variable:       stime        Num. events:       75 \nTies:                     Efron                              \n-------------------------------------------------------------\n         log HR log HR SE   HR      t    P>|t|  [0.025 0.975]\n-------------------------------------------------------------\nyear    -0.1196    0.0673 0.8872 -1.7765 0.0757 0.7775 1.0124\nage      0.0296    0.0135 1.0300  2.1872 0.0287 1.0031 1.0577\nsurgery -0.9873    0.4363 0.3726 -2.2632 0.0236 0.1584 0.8761\n=============================================================\nConfidence intervals are for the hazard ratios\n```\n:::\n:::\n\n\n",
    "supporting": [
      "16-Python_files\\figure-pdf"
    ],
    "filters": []
  }
}