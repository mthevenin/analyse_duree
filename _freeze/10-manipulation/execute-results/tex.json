{
  "hash": "49a840bb49c98cf91d05fc25fcd37144",
  "result": {
    "markdown": "\n\n# Eléments de mise en forme des données\n\nCe qui suit est un premier jet réalisé en 2023 \n\n\nPackages utilisés:\n\n\n\n::: {.cell}\n\n```{.r .cell-code  code-fold=\"true\" code-summary=\"Code\"}\nlibrary(dplyr)\nlibrary(tidyr)\nlibrary(knitr)\n```\n:::\n\n\n\n\n\n## Calcul des variables d'analyses\n\nConstruction de la base: \n\n\n\n::: {.cell}\n\n```{.r .cell-code  code-fold=\"true\" code-summary=\"Code\"}\ndf = data.frame(id  =  c(1, 1, 1, 2),\n                deb =  c(2020, 2023, 2024, 2022),\n                fin =  c(2021, 2024, 2025, NA), \n                  x =  c(1,2,1,2))\nkable(df)\n```\n\n::: {.cell-output-display}\n| id|  deb|  fin|  x|\n|--:|----:|----:|--:|\n|  1| 2020| 2021|  1|\n|  1| 2023| 2024|  2|\n|  1| 2024| 2025|  1|\n|  2| 2022|   NA|  2|\n:::\n:::\n\n\n\nOn supposera que l'année de collecte, pour toutes les observations, est **2025** ^[Ici on a une enquête réalisée une même année pour toute les observations, ce n'est pas toujours le cas. De même au lieu de l'année, si les datations avaient été données par l'âge, au moment de l'enquête l'âge varierait d'une personne à une autre. Ces datations différentes (année ou âge) peuvent être présentes dans chaque module biographique d'une enquête, ou dans le fichier des caractéristiques fixes. Dans ce cas l'information devra être récupérée].\n\nSi cela n'est pas donné dans le module biographique, il peut être intéressant de construire les numéros de séquences des trajectoires.\n\n\n\n::: {.cell}\n\n```{.r .cell-code  code-fold=\"true\" code-summary=\"Code\"}\ndf$nseq = 1 \ndf = df %>% group_by(id) %>% mutate(nseq = cumsum(nseq))  \n\nkable(df)\n```\n\n::: {.cell-output-display}\n| id|  deb|  fin|  x| nseq|\n|--:|----:|----:|--:|----:|\n|  1| 2020| 2021|  1|    1|\n|  1| 2023| 2024|  2|    2|\n|  1| 2024| 2025|  1|    3|\n|  2| 2022|   NA|  2|    1|\n:::\n:::\n\n\n\n**Exemple 1 : durée de séjour de la première séquence observée** \n\nSupposons que x traduit un type de relation/union, par exemple x=1 est une relation non cohabitante et x=2 est une relation cohabitante.\nOn s'intéresse à la durée de la première relation, sans distinction entre 1 et 2. Il suffit de séléctionner la première séquence.\n\n\n\n::: {.cell}\n\n```{.r .cell-code  code-fold=\"true\" code-summary=\"Code\"}\ndf = filter(df, nseq==1)\n```\n:::\n\n\n\nLa variable de fin va permettre de repérer les informations censurées, et de générer la variable d'évènement. \nA ce niveau il est donc important de ne pas encore remplacer la date de censure par sa valeur.\n\n* Si *fin* est une valeur manquante: observation censurée.\n* Si *fin* est une valeur renseignée: occurence de l'évènement.\n\n\n\n::: {.cell}\n\n```{.r .cell-code  code-fold=\"true\" code-summary=\"Show the code\"}\ndf$e = ifelse(is.na(df$fin), 0,1)\n\nkable(df)\n```\n\n::: {.cell-output-display}\n| id|  deb|  fin|  x| nseq|  e|\n|--:|----:|----:|--:|----:|--:|\n|  1| 2020| 2021|  1|    1|  1|\n|  2| 2022|   NA|  2|    1|  0|\n:::\n:::\n\n\n\nPour la variable de durée ^[La mesure est ici discrète/groupée, il me semble toujours préférable d'allonger les durées à +1. On démarre donc toujours un premier janvier pour terminer un 31 décembre sur l'information est donnée par des année. Ici t=1 représente la première année après la sortie des études. Une personne qui aura eu un emploi durant cette année, l'aura eu durant cette première année, que ce soit 2 semaines après ou 11 mois après. Si on disposait des mois, cela pourrait être intéressant de modifier cette métrique temporelle. Voir exemple 3], une repéré les observations censurées, elle est calculée directement avec les variables *fin* et *deb*. \n\n\n\n::: {.cell}\n\n```{.r .cell-code  code-fold=\"true\" code-summary=\"Show the code\"}\ndf$dur = ifelse(df$e==1, df$fin - df$deb + 1, 2025 - df$deb + 1)\n\nkable(df)\n```\n\n::: {.cell-output-display}\n| id|  deb|  fin|  x| nseq|  e| dur|\n|--:|----:|----:|--:|----:|--:|---:|\n|  1| 2020| 2021|  1|    1|  1|   2|\n|  2| 2022|   NA|  2|    1|  0|   4|\n:::\n:::\n\n\n\n**Exemple 2 : changement de métrique temporelle**\n\nToujours avec le même exemple, mais en ajoutant une observation, supposons que l'on dispose également de l'information sur les mois. Sur les mois où l'évènement à eu lieu, mais également sur les mois où l'enquête a été réalisée.\n\n\n\n::: {.cell}\n\n```{.r .cell-code  code-fold=\"true\" code-summary=\"Code\"}\ndf2 = data.frame(id  = c(1, 1, 1, 2,3),\n                deb  = c(2020, 2023, 2024, 2022, 2021),\n                debm = c(2,5,3,10,9),\n                fin  = c(2021, 2024, 2025, NA,2021), \n                finm = c(4,2,12,NA,11), \n                x    = c(1,2,1,2,1),\n                enq  = c(2025,2025,2025,2025,2025),\n                enqm = c(4,4,4,5,4))\n\ndf2$nseq = 1 \ndf2 = df2 %>% group_by(id) %>% mutate(nseq = cumsum(nseq))  \n\nkable(df2)\n```\n\n::: {.cell-output-display}\n| id|  deb| debm|  fin| finm|  x|  enq| enqm| nseq|\n|--:|----:|----:|----:|----:|--:|----:|----:|----:|\n|  1| 2020|    2| 2021|    4|  1| 2025|    4|    1|\n|  1| 2023|    5| 2024|    2|  2| 2025|    4|    2|\n|  1| 2024|    3| 2025|   12|  1| 2025|    4|    3|\n|  2| 2022|   10|   NA|   NA|  2| 2025|    5|    1|\n|  3| 2021|    9| 2021|   11|  1| 2025|    4|    1|\n:::\n:::\n\n\n\nOn remarque que la nouvelle observation (id=3) a connu l'évènement, ici la fin de la relation, la même année qu'au début d'exposition (le début de la relation).... mais au bout de 2,6,11 mois???? Commeon dispose de l'information sur les mois de début et de fin cela peut être intéressant de l'exploite. De la même manière si l'enquête a été réalisée la même année, les entretiens n'ont pas eu lieu le même mois. On aura besoin de cette information pour les observations censurées.\n\n\nDe nouveau on sélectionne la première séquence, et pour la lisibilité de la base on retire les informations qui ne seront pas ou plus exploitées (*nseq*, *x*).\n\n\n\n::: {.cell}\n\n```{.r .cell-code  code-fold=\"true\" code-summary=\"Show the code\"}\ndf2 = filter(df2,nseq==1)\ndf2 = select(df2, -c(x,nseq))\n\nkable(df2)\n```\n\n::: {.cell-output-display}\n| id|  deb| debm|  fin| finm|  enq| enqm|\n|--:|----:|----:|----:|----:|----:|----:|\n|  1| 2020|    2| 2021|    4| 2025|    4|\n|  2| 2022|   10|   NA|   NA| 2025|    5|\n|  3| 2021|    9| 2021|   11| 2025|    4|\n:::\n:::\n\n\n\nOn génère la variable censure/évènement (toujours à faire avant la variable de durée) de la même manière que pour l'exemple 1.\n\n\n\n::: {.cell}\n\n```{.r .cell-code  code-fold=\"true\" code-summary=\"Show the code\"}\ndf2$e = ifelse(is.na(df2$fin), 0, 1)\n\nkable(df2)\n```\n\n::: {.cell-output-display}\n| id|  deb| debm|  fin| finm|  enq| enqm|  e|\n|--:|----:|----:|----:|----:|----:|----:|--:|\n|  1| 2020|    2| 2021|    4| 2025|    4|  1|\n|  2| 2022|   10|   NA|   NA| 2025|    5|  0|\n|  3| 2021|    9| 2021|   11| 2025|    4|  1|\n:::\n:::\n\n\n\nPour la variable de durée, le principe est de multiplié par 12 la différence entre l'année de fin et l'année de début et d'ajouter la différence entre le mois de fin et le mois de début.  \nPour les observations censurées, ici l'année de fin est identique mais les mois varient. En terme de programmation, surtout si avec R on utilise `ifelse`, il est préférable d'y aller doucement en créant une durée pour les observations qui ont connu l'évènement et une durée pour les observations censurées. Puis de regrouper les deux cas. C'est ce qui est fait dans le code qui suit. \n\nDurée selon les valeurs de *e*: \n\n\n\n::: {.cell}\n\n```{.r .cell-code  code-fold=\"true\" code-summary=\"Show the code\"}\ndf2$dur1 = ifelse(df2$e==1, 12*(df2$fin - df2$deb) + (df2$finm - df2$debm),  0) \ndf2$dur0 = ifelse(df2$e==0, 12*(2025 - df2$deb)    + (df2$enqm  - df2$debm), 0) \n\nkable(df2)\n```\n\n::: {.cell-output-display}\n| id|  deb| debm|  fin| finm|  enq| enqm|  e| dur1| dur0|\n|--:|----:|----:|----:|----:|----:|----:|--:|----:|----:|\n|  1| 2020|    2| 2021|    4| 2025|    4|  1|   14|    0|\n|  2| 2022|   10|   NA|   NA| 2025|    5|  0|    0|   31|\n|  3| 2021|    9| 2021|   11| 2025|    4|  1|    2|    0|\n:::\n:::\n\n\n\nOn regroupe par simple sommation (le *else* étant 0).\n\n\n\n::: {.cell}\n\n```{.r .cell-code  code-fold=\"true\" code-summary=\"Show the code\"}\ndf2$dur  = df2$dur1 + df2$dur0\n\ndf2 = select(df2, -c(dur1,dur0))\n\nkable(df2)\n```\n\n::: {.cell-output-display}\n| id|  deb| debm|  fin| finm|  enq| enqm|  e| dur|\n|--:|----:|----:|----:|----:|----:|----:|--:|---:|\n|  1| 2020|    2| 2021|    4| 2025|    4|  1|  14|\n|  2| 2022|   10|   NA|   NA| 2025|    5|  0|  31|\n|  3| 2021|    9| 2021|   11| 2025|    4|  1|   2|\n:::\n:::\n\n\n\nOn dispose ainsi des éléments nécessaire pour faire une analyse de durée avec une métrique mensuelle ^[Contrairement au durée annuelle je n'ai pas ajouté 1 à chaque durée, ce qui est de nouveau envisageable par exemple si on veut explicitement indiquer les évènements qui ont lieu le premier mois. Pour id=3 la relation a t-elle durée du 1er septembre au 30 novembre, ou du 30 septembre au 1er novembre?? On a toujours un problème de précision, mais ici d'une trentaine de jours].\n\n\n**Exemple 3 : importation d'un début d'expositon externe** \n\nOn repart de la première base\n\n\n\n::: {.cell}\n\n:::\n\n::: {.cell}\n::: {.cell-output-display}\n| id|  deb|  fin|  x| nseq|\n|--:|----:|----:|--:|----:|\n|  1| 2020| 2021|  1|    1|\n|  1| 2023| 2024|  2|    2|\n|  1| 2024| 2025|  1|    3|\n|  2| 2022|   NA|  2|    1|\n:::\n:::\n\n\n\n\nOn suppose maintenant que x traduit des situations sur le marché du travail. Par exemple **x=1** est un emploi en CDD et **x=2** un emploi en CDI. On s'intéresse à la durée entre la fin des études et le premier emploi, quel que soit sont type.\n\n- On ne dispose pas ici de toutes l'information pour calculer la durée, soit la fin des études. Elle peut être donnée dans une base classique regroupant l'ensemble des caractéristiques individuelles de type fixe (année de naissance, sexe...).\n- Comme on s'intéresse à la durée de recherche du premier emploi, dans le module biographique la date de début va devenir la date de fin.\n- Pour les observations présente dans la base biographique, il n'y a pas de censure à droite. Mais si on regarde le fichier des caractéristiques générales, fixe:\n\n\n\n\n::: {.cell}\n\n```{.r .cell-code  code-fold=\"true\" code-summary=\"Show the code\"}\netude = data.frame(id = c(1,2,3), fin_etude = c(2020,2021,2023))\nkable(etude)\n```\n\n::: {.cell-output-display}\n| id| fin_etude|\n|--:|---------:|\n|  1|      2020|\n|  2|      2021|\n|  3|      2023|\n:::\n:::\n\n\n\nUne nouvelle observation  (id=3) apparaît. Au moment de l'enquête, elle n'a pas (**encore**) trouvé un emploi depuis la fin de ces études. On a donc une observation qui sera censurée.\n\n::: callout-note\nCertaines bases biographiques peuvent être structurées avec des trajectoires strictement continue, l'année (l'âge) de fin étant l'année (l'âge) de début de la trajectoire suivante. Dans ce cas, l'information serait immédiatement disponible, avec la présence d'un nombre de séquences plus important dans la base. \n:::\n\nOn va devoir: \n\n* Sélectionner la première sequence d'emploi dans la base df (variable *nseq*).\n* La fusionner avec la base étude.\n\nAvant la fusion, on peut conserver seulement les informations nécessaires (id, deb). La variable *deb* va changer également de statut en devenant l'année de *fin* de la période de recherche d'emploi.  \n\n\n\n::: {.cell}\n\n```{.r .cell-code  code-fold=\"true\" code-summary=\"Show the code\"}\ndf = filter(df, nseq==1)\ndf = select(df, -c(fin,x,nseq))\n\ndf = rename(df, fin = deb)\nkable(df)\n```\n\n::: {.cell-output-display}\n| id|  fin|\n|--:|----:|\n|  1| 2020|\n|  2| 2022|\n:::\n:::\n\n\n\nAprès la fusion: \n\n\n\n::: {.cell}\n\n```{.r .cell-code  code-fold=\"true\" code-summary=\"Show the code\"}\ndf = full_join(etude, df,  by = c('id'))\n\ndf = rename(df, deb = fin_etude)\n\nkable(df)\n```\n\n::: {.cell-output-display}\n| id|  deb|  fin|\n|--:|----:|----:|\n|  1| 2020| 2020|\n|  2| 2021| 2022|\n|  3| 2023|   NA|\n:::\n:::\n\n\n\nOn a toutes les informations pour générer la variable censure/évènement et la variable de durée:\n\n\n\n::: {.cell}\n\n```{.r .cell-code  code-fold=\"true\" code-summary=\"Show the code\"}\ndf$e = ifelse(is.na(df$fin),0,1)\n\ndf$dur = ifelse(df$e, df$fin - df$deb + 1, 2025 - df$deb + 1)\nkable(df)\n```\n\n::: {.cell-output-display}\n| id|  deb|  fin|  e| dur|\n|--:|----:|----:|--:|---:|\n|  1| 2020| 2020|  1|   1|\n|  2| 2021| 2022|  1|   2|\n|  3| 2023|   NA|  0|   3|\n:::\n:::\n\n\n\n\n## Appariement de modules biographiques \n\nOn repart de la première base, avec les numéros de séquence.\n\n\n\n::: {.cell}\n::: {.cell-output-display}\n| id|  deb|  fin|  x| nseq|\n|--:|----:|----:|--:|----:|\n|  1| 2020| 2021|  1|    1|\n|  1| 2023| 2024|  2|    2|\n|  1| 2024| 2025|  1|    3|\n|  2| 2022|   NA|  2|    1|\n:::\n:::\n\n\n\n### Mise en forme d'une base\n\nPour apparier des informations de plusieurs modules biographiques, on doit transformer les bases en format individus-séquences en format individus-périodes (ici individus années).\n\n* **Etape 1**: allongement sur chaque séquence après avoir générées leur durée\n* **Etape 2**: générer une variable de période (année) sur chaque ligne. Elle servira pour l'appariement.\n\n**Pourquoi ne pas utiliser la simple différence entre la fin et le début ?**\n\nDurée (fin - début) et allongement de la base:\n\nOn ne génère pas des variables d'analyse, on aurait besoin de l'information sur l'année de l'enquête pour les informations censurées. \n\n\n\n::: {.cell}\n\n```{.r .cell-code  code-fold=\"true\" code-summary=\"Show the code\"}\ndf$fin[is.na(df$fin)] = 2025\n\nkable(df)\n```\n\n::: {.cell-output-display}\n| id|  deb|  fin|  x| nseq|\n|--:|----:|----:|--:|----:|\n|  1| 2020| 2021|  1|    1|\n|  1| 2023| 2024|  2|    2|\n|  1| 2024| 2025|  1|    3|\n|  2| 2022| 2025|  2|    1|\n:::\n:::\n\n\n\n\nAllongement de la base:\n\n\n\n::: {.cell}\n\n```{.r .cell-code  code-fold=\"true\" code-summary=\"Show the code\"}\ndf1 = df\ndf1$dur1 = df1$fin - df1$deb\n\ndf1$dur1b = df1$dur1 # uncount supprime la variable d'origine \ndf1 = uncount(df1,dur1b)\n\nkable(df1)\n```\n\n::: {.cell-output-display}\n| id|  deb|  fin|  x| nseq| dur1|\n|--:|----:|----:|--:|----:|----:|\n|  1| 2020| 2021|  1|    1|    1|\n|  1| 2023| 2024|  2|    2|    1|\n|  1| 2024| 2025|  1|    3|    1|\n|  2| 2022| 2025|  2|    1|    3|\n|  2| 2022| 2025|  2|    1|    3|\n|  2| 2022| 2025|  2|    1|    3|\n:::\n:::\n\n\n\n\nPour générer la variable période (année), on a besoin d'un compteur qui sera associé à la variable *deb*. On doit bien contrôler l'opération par identifiant et numéro de séquence.\n\n\n\n::: {.cell}\n\n```{.r .cell-code  code-fold=\"true\" code-summary=\"Show the code\"}\ndf1$c = 1\ndf1 = df1 %>% group_by(id,nseq) %>% mutate(year = deb  + cumsum(c)) \n\nkable(df1)\n```\n\n::: {.cell-output-display}\n| id|  deb|  fin|  x| nseq| dur1|  c| year|\n|--:|----:|----:|--:|----:|----:|--:|----:|\n|  1| 2020| 2021|  1|    1|    1|  1| 2021|\n|  1| 2023| 2024|  2|    2|    1|  1| 2024|\n|  1| 2024| 2025|  1|    3|    1|  1| 2025|\n|  2| 2022| 2025|  2|    1|    3|  1| 2023|\n|  2| 2022| 2025|  2|    1|    3|  1| 2024|\n|  2| 2022| 2025|  2|    1|    3|  1| 2025|\n:::\n:::\n\n\n\n**Problème**: les années de début ne sont pas correncte: 2021 au lieu de 2020 pour la première séquence de id=1 par exemple. \n\n::: callout-important\nOn doit donc impérativement augmenter la différence entre la fin et le début par +1 pour que l'ensemble des périodes (années) soit couvertes. \n:::\n\nOn reprend donc les opérations précédentes mais avec **durée = fin - debut + 1**\n\n* Allongement de la base avec durée augmentée \n\n\n\n::: {.cell}\n\n```{.r .cell-code  code-fold=\"true\" code-summary=\"Show the code\"}\ndf2 = df\ndf2$dur2 = df2$fin - df2$deb + 1\n\ndf2$dur2b = df2$dur2 # uncount supprime la variable d'origine \ndf2 = uncount(df2,dur2b)\n\nkable(df2)\n```\n\n::: {.cell-output-display}\n| id|  deb|  fin|  x| nseq| dur2|\n|--:|----:|----:|--:|----:|----:|\n|  1| 2020| 2021|  1|    1|    2|\n|  1| 2020| 2021|  1|    1|    2|\n|  1| 2023| 2024|  2|    2|    2|\n|  1| 2023| 2024|  2|    2|    2|\n|  1| 2024| 2025|  1|    3|    2|\n|  1| 2024| 2025|  1|    3|    2|\n|  2| 2022| 2025|  2|    1|    4|\n|  2| 2022| 2025|  2|    1|    4|\n|  2| 2022| 2025|  2|    1|    4|\n|  2| 2022| 2025|  2|    1|    4|\n:::\n:::\n\n\n\n\n* Création de la variable *year*: **sur chaque individus-séquences, la somme entre le compteur et l'année de début doit être réduite de 11**.\n\n\n\n\n::: {.cell}\n\n```{.r .cell-code  code-fold=\"true\" code-summary=\"Show the code\"}\ndf2$c = 1\ndf2 = df2 %>% group_by(id,nseq) %>% mutate(year = deb  + cumsum(c) - 1)\n\ndf2 = select(df2, -c(deb,fin,dur2))\n\n\nkable(df2)\n```\n\n::: {.cell-output-display}\n| id|  x| nseq|  c| year|\n|--:|--:|----:|--:|----:|\n|  1|  1|    1|  1| 2020|\n|  1|  1|    1|  1| 2021|\n|  1|  2|    2|  1| 2023|\n|  1|  2|    2|  1| 2024|\n|  1|  1|    3|  1| 2024|\n|  1|  1|    3|  1| 2025|\n|  2|  2|    1|  1| 2022|\n|  2|  2|    1|  1| 2023|\n|  2|  2|    1|  1| 2024|\n|  2|  2|    1|  1| 2025|\n:::\n:::\n\n\n\nLes années sont toutes couvertes....mais un peu trop. En effet, lorsque les trajectoires sont continues soit\nlorsque l'année de fin d'une séquence est identique à l'année de début de la suivante, les années vont être doublonnées. On doit dont supprimer ce doublon. \n\n* Suppression des doublons des trajectoires continues.\n\nDe nouveaux on doit faire un choix, soit on priviligie l'année de fin, soit on privilégie l'année de début. \nLes applications ont des fonctions qui permettent de supprimer les doublons^[avec R par exemple la fonction `unique` de dplyr]. On peut le faire manuellement en regardant pour chaque personnes-années le nombre de doublon. Cela se fait facilement à l'aide d'un compteur, ici la variable *nyear*.\n\n\n\n::: {.cell}\n\n```{.r .cell-code  code-fold=\"true\" code-summary=\"Show the code\"}\ndf2 = df2 %>% group_by(id,year) %>% mutate(nyear = cumsum(c))\n\nkable(df2)\n```\n\n::: {.cell-output-display}\n| id|  x| nseq|  c| year| nyear|\n|--:|--:|----:|--:|----:|-----:|\n|  1|  1|    1|  1| 2020|     1|\n|  1|  1|    1|  1| 2021|     1|\n|  1|  2|    2|  1| 2023|     1|\n|  1|  2|    2|  1| 2024|     1|\n|  1|  1|    3|  1| 2024|     2|\n|  1|  1|    3|  1| 2025|     1|\n|  2|  2|    1|  1| 2022|     1|\n|  2|  2|    1|  1| 2023|     1|\n|  2|  2|    1|  1| 2024|     1|\n|  2|  2|    1|  1| 2025|     1|\n:::\n:::\n\n\n\nSi on souhaite garder l'année de fin on filtre les observations en conservant celles dont nyear=1. Si on souhaite privilégier les années de début on foltre les observations en conservant celles dont nyear=2. \nSi on souhaite conserver les années de fin de séquence:\n\n\n\n::: {.cell}\n\n```{.r .cell-code  code-fold=\"true\" code-summary=\"Show the code\"}\ndf2 = filter(df2, nyear==1)\n\ndf2 = select(df2, -c(nseq,c,nyear))\n\nkable(df2)\n```\n\n::: {.cell-output-display}\n| id|  x| year|\n|--:|--:|----:|\n|  1|  1| 2020|\n|  1|  1| 2021|\n|  1|  2| 2023|\n|  1|  2| 2024|\n|  1|  1| 2025|\n|  2|  2| 2022|\n|  2|  2| 2023|\n|  2|  2| 2024|\n|  2|  2| 2025|\n:::\n:::\n\n\n\n\n::: callout-important\n\n### En résumé\n\n* A la date (année/âge) de censure remplacer la valeur manquante par sa valeur. Si ultérieurement on a besoin  de garder l'information sur la censure -  valeur manquante  - , on peut générer une variable mirroir de *fin*.\n* Sur chaque séquence calculer la durée avec une augmentation de +1.\n* Créer une variable période (année) sur chaque ligne. Elle servira à définir la clé d'appariement. \n* Supprimer les doublons sur les transition continue $fin_t = debut_{t+1}$.\n\n:::\n\n### Fusion des informations biographiques\n\n\n#### Fusion avec l'ensemble des périodes observables\n\nPour commencer par un exemple plutôt simple, on note que pour id=1 l'année 2022 n'est pas renseignée (trajectoire non continue). Si on reprend un exemple précédent (relations de couple), cette année pourrait être identifiée comme une période sans relation. \nUne façon simple de boucher ce type \"trous\", est d'utiliser les années de naissances des individus, et de créer une base individus-périodes  qui couvre toutes les années de vie de l'individu jusqu'à l'enquête. On remontera jusque là, mais on va par exemple considérer que pour id=1 et id=2 ce *début de tout* est en 2018.\n\n\n\n::: {.cell}\n\n```{.r .cell-code  code-fold=\"true\" code-summary=\"Show the code\"}\ndftout = data.frame(id  =  c(1, 2),\n                    t0  =  c(2018, 2018))\n\nkable(dftout)    \n```\n\n::: {.cell-output-display}\n| id|   t0|\n|--:|----:|\n|  1| 2018|\n|  2| 2018|\n:::\n:::\n\n\n\n\n* On ajoute l'information sur l'année de l'enquête (2025).\n* On génère la durée \n* On allonge la base\n* On génère la variable année sur chaque ligne (on contrôle seulement sur *id*)\n\n\n\n::: {.cell}\n\n```{.r .cell-code  code-fold=\"true\" code-summary=\"Show the code\"}\ndftout$tmax = 2025\n\ndftout$dur  = dftout$tmax - dftout$t0 + 1\n\ndftout = uncount(dftout,dur)\n\n\ndftout$c = 1\ndftout = dftout %>% group_by(id) %>% mutate(year = t0  + cumsum(c) - 1)\n\ndftout = select(dftout, -c(t0,tmax,c))\n\nkable(dftout)    \n```\n\n::: {.cell-output-display}\n| id| year|\n|--:|----:|\n|  1| 2018|\n|  1| 2019|\n|  1| 2020|\n|  1| 2021|\n|  1| 2022|\n|  1| 2023|\n|  1| 2024|\n|  1| 2025|\n|  2| 2018|\n|  2| 2019|\n|  2| 2020|\n|  2| 2021|\n|  2| 2022|\n|  2| 2023|\n|  2| 2024|\n|  2| 2025|\n:::\n:::\n\n\n\nOn peut maintenant apparier cette couverture de toutes les années de vie jusqu'à l'enquête à la base biographique:\n\n\n\n\n::: {.cell}\n\n```{.r .cell-code  code-fold=\"true\" code-summary=\"Show the code\"}\ndf2 = full_join(df2, dftout, by = c(\"id\",\"year\"))\n\ndf2 = arrange(df2, id, year)\nkable(df2)    \n```\n\n::: {.cell-output-display}\n| id|  x| year|\n|--:|--:|----:|\n|  1| NA| 2018|\n|  1| NA| 2019|\n|  1|  1| 2020|\n|  1|  1| 2021|\n|  1| NA| 2022|\n|  1|  2| 2023|\n|  1|  2| 2024|\n|  1|  1| 2025|\n|  2| NA| 2018|\n|  2| NA| 2019|\n|  2| NA| 2020|\n|  2| NA| 2021|\n|  2|  2| 2022|\n|  2|  2| 2023|\n|  2|  2| 2024|\n|  2|  2| 2025|\n:::\n:::\n\n\n\nPour supprimer les informations qui précèdent la première séquence de la biographie, on peut générer un compteur sur la variable x après avoir remplacer ses valeurs manquantes par des 0. On gardera les lignes pour lesquels ce compteur est supérieur à 1.  \n\n\n\n::: {.cell}\n\n```{.r .cell-code  code-fold=\"true\" code-summary=\"Show the code\"}\ndf2$x[is.na(df2$x)] = 0\n\ndf2 = df2 %>% group_by(id) %>% mutate(nx = cumsum(x))\n\nkable(df2)    \n```\n\n::: {.cell-output-display}\n| id|  x| year| nx|\n|--:|--:|----:|--:|\n|  1|  0| 2018|  0|\n|  1|  0| 2019|  0|\n|  1|  1| 2020|  1|\n|  1|  1| 2021|  2|\n|  1|  0| 2022|  2|\n|  1|  2| 2023|  4|\n|  1|  2| 2024|  6|\n|  1|  1| 2025|  7|\n|  2|  0| 2018|  0|\n|  2|  0| 2019|  0|\n|  2|  0| 2020|  0|\n|  2|  0| 2021|  0|\n|  2|  2| 2022|  2|\n|  2|  2| 2023|  4|\n|  2|  2| 2024|  6|\n|  2|  2| 2025|  8|\n:::\n:::\n\n\n\nOn supprime les lignes lorsque nx=0.\n\n\n\n::: {.cell}\n\n```{.r .cell-code  code-fold=\"true\" code-summary=\"Show the code\"}\ndf2 = filter(df2, nx>0)\n\ndf2 = select(df2, -c(nx))\n\nkable(df2)    \n```\n\n::: {.cell-output-display}\n| id|  x| year|\n|--:|--:|----:|\n|  1|  1| 2020|\n|  1|  1| 2021|\n|  1|  0| 2022|\n|  1|  2| 2023|\n|  1|  2| 2024|\n|  1|  1| 2025|\n|  2|  2| 2022|\n|  2|  2| 2023|\n|  2|  2| 2024|\n|  2|  2| 2025|\n:::\n:::\n\n\n\n\n#### Fusion avec une autre base biographique\n\nOn peut être amené à fusionner plusieurs modules biographique. Jusqu'à présent, une même année, tous les individus ne pouvaient être que dans une situation, par exemple une seul emploi, un seul lieu de résidence etc... \nPour certains phénomènes, une même années ou pendant une période plus longue on peut observer simultanément plusieurs états différent, ou plus classiquement observer une somme d'un même état. On parle ici d'***overlapping***.\nCe type de situation est typiquement celle qu'on observe avec le nombre d'enfants.\n\nSupposons que le base ci-dessous traduit la naissance et potentiellement le décès des enfants.  \n\n\n\n::: {.cell}\n\n```{.r .cell-code  code-fold=\"true\" code-summary=\"Show the code\"}\ndfy = data.frame(id  =  c(1, 2, 2),\n                deb =  c(2022, 2019, 2023),\n                fin =  c(NA, 2024,NA), \n                nseq =  c(1,1,2))\n\nkable(dfy)\n```\n\n::: {.cell-output-display}\n| id|  deb|  fin| nseq|\n|--:|----:|----:|----:|\n|  1| 2022|   NA|    1|\n|  2| 2019| 2024|    1|\n|  2| 2023|   NA|    2|\n:::\n:::\n\n\n\n\n* id=1 a un premier enfant en 2022 qui est toujours en vie au moment de l'enquête (2025)\n* id=2:\n  * A un premier enfant en 2019 qui décède en 2024\n  * A un second  enfant en 2023, toujours en vie au moment de l'enquête\n  * De la naissance du second enfant au décès du premier, on va donc avoir des doublons (overlapping) sur les années\n  \nSi on reprend les manipulations précédentes jusqu'à la création de la variable *year*: \n\n\n\n::: {.cell}\n\n```{.r .cell-code  code-fold=\"true\" code-summary=\"Show the code\"}\ndfy$fin[is.na(dfy$fin)] = 2025\ndfy$dur = dfy$fin - dfy$deb + 1\n\ndfy$durb = dfy$dur  # Uncount supprime la variable d'origine \ndfy = uncount(dfy,durb)\n\ndfy$c = 1\ndfy = dfy %>% group_by(id,nseq) %>% mutate(year = deb  + cumsum(c) - 1)\n```\n:::\n\n\n\nLa variable *year* est bien renseignée 2 fois pour les années 2023 et 2024. \n\nOn peut s'intéresser au fait d'avoir ou non un enfant, ou de manière plus générale au nombre d'enfant. En créant cette information, on se donne également le moyen de corriger cet overlapping: \n\n- On peut de nouveau générer un compteur contrôlé par individu année\n- En génerant un total de ligne doublonnée, on récupèrera par exemple ici le nombre d'enfant en vie chaque année. \n- En ne gardant que la ligne ou le compteur est égal à 1, on supprime les doublons tout en gardant l'information sur le nombre d'enfant en vie une année donnée.\n\n\n\n\n::: {.cell}\n\n```{.r .cell-code  code-fold=\"true\" code-summary=\"Show the code\"}\ndfy = dfy %>% group_by(id,year) %>% mutate(ny = cumsum(c))\ndfy = dfy %>% group_by(id,year) %>% mutate(tot_y =  sum(c))\n\nkable(dfy)\n```\n\n::: {.cell-output-display}\n| id|  deb|  fin| nseq| dur|  c| year| ny| tot_y|\n|--:|----:|----:|----:|---:|--:|----:|--:|-----:|\n|  1| 2022| 2025|    1|   4|  1| 2022|  1|     1|\n|  1| 2022| 2025|    1|   4|  1| 2023|  1|     1|\n|  1| 2022| 2025|    1|   4|  1| 2024|  1|     1|\n|  1| 2022| 2025|    1|   4|  1| 2025|  1|     1|\n|  2| 2019| 2024|    1|   6|  1| 2019|  1|     1|\n|  2| 2019| 2024|    1|   6|  1| 2020|  1|     1|\n|  2| 2019| 2024|    1|   6|  1| 2021|  1|     1|\n|  2| 2019| 2024|    1|   6|  1| 2022|  1|     1|\n|  2| 2019| 2024|    1|   6|  1| 2023|  1|     2|\n|  2| 2019| 2024|    1|   6|  1| 2024|  1|     2|\n|  2| 2023| 2025|    2|   3|  1| 2023|  2|     2|\n|  2| 2023| 2025|    2|   3|  1| 2024|  2|     2|\n|  2| 2023| 2025|    2|   3|  1| 2025|  1|     1|\n:::\n:::\n\n\n\nIl ne reste plus qu'à supprimer les lignes où *ny>1*\n\n\n\n\n::: {.cell}\n\n```{.r .cell-code  code-fold=\"true\" code-summary=\"Show the code\"}\ndfy = filter(dfy, ny==1)\ndfy = select(dfy, -c(ny,deb, fin, dur, nseq, c))\n\nkable(dfy)\n```\n\n::: {.cell-output-display}\n| id| year| tot_y|\n|--:|----:|-----:|\n|  1| 2022|     1|\n|  1| 2023|     1|\n|  1| 2024|     1|\n|  1| 2025|     1|\n|  2| 2019|     1|\n|  2| 2020|     1|\n|  2| 2021|     1|\n|  2| 2022|     1|\n|  2| 2023|     2|\n|  2| 2024|     2|\n|  2| 2025|     1|\n:::\n:::\n\n\n\nAvec une ligne par année, on peut la fusionner avec une autre base biographique en format individus-années (même principe qu'avec la fusion avec la base sur toutes les années de vie).\n\n\n\n::: {.cell}\n\n```{.r .cell-code  code-fold=\"true\" code-summary=\"Show the code\"}\ndf2y = full_join(dfy, df2, by = c(\"id\",\"year\"))\n\ndf2y = arrange(df2y, id,year)\n\ndf2y = select(df2y, c(id,year,x,tot_y))\n\ndf2y$tot_y[is.na(df2y$tot_y)] = 0\ndf2y$x[is.na(df2y$x)]   = 0\n\nkable(df2y)\n```\n\n::: {.cell-output-display}\n| id| year|  x| tot_y|\n|--:|----:|--:|-----:|\n|  1| 2020|  1|     0|\n|  1| 2021|  1|     0|\n|  1| 2022|  0|     1|\n|  1| 2023|  2|     1|\n|  1| 2024|  2|     1|\n|  1| 2025|  1|     1|\n|  2| 2019|  0|     1|\n|  2| 2020|  0|     1|\n|  2| 2021|  0|     1|\n|  2| 2022|  2|     1|\n|  2| 2023|  2|     2|\n|  2| 2024|  2|     2|\n|  2| 2025|  2|     1|\n:::\n:::\n\n\n\n\n## Sélection d'un type de séquence et mise en forme pour l'analyse \n\n\n\n## Durée jusqu'à la première séquence\n\n\n\n::: {.cell}\n\n```{.r .cell-code  code-fold=\"true\" code-summary=\"Show the code\"}\ndf =  data.frame(id  =  c( 1, 1, 1, 2, 3, 3, 4),\n                 deb =  c(2018, 2022, 2024, 2019, 2023, 2024, 2023),\n                 fin =  c(2021, 2024, 2025, NA, 2024, NA, NA), \n                 y  =   c(1, 2, 1, 2, 3, 2, 1),\n                 nseq = c(1, 2, 3, 1, 1, 2, 1)\n                 )\n\nkable(df)\n```\n\n::: {.cell-output-display}\n| id|  deb|  fin|  y| nseq|\n|--:|----:|----:|--:|----:|\n|  1| 2018| 2021|  1|    1|\n|  1| 2022| 2024|  2|    2|\n|  1| 2024| 2025|  1|    3|\n|  2| 2019|   NA|  2|    1|\n|  3| 2023| 2024|  3|    1|\n|  3| 2024|   NA|  2|    2|\n|  4| 2023|   NA|  1|    1|\n:::\n:::\n\n\n\nOn va s'intéresser à la durée jusqu'à l'occurence de la séquence de type 2 ou 3 (variable *y*). On considéra que le début de l'exposition est donné par la variable *deb* sur la première séquence.\n\n* id=1: début de l'exposition/observation en 2018, observe l'évènement en 2022.\n* id=2: début de l'exposition/observation en 2019, observe l'évènement la même année.\n* id=3: début de l'exposition/observation en 2019, observe l'évènement la même année. \n* id=4: début de l'exposition/observation en 2023, n'a pas connu l'évènement au moment de l'enquête.\n\n**Recupération de l'année de l'évènement**\n\nOn peut repérer la présence d'une des deux séquences d'intérêt avec une indicatrice. \n\n\n\n::: {.cell}\n\n```{.r .cell-code  code-fold=\"true\" code-summary=\"Show the code\"}\ndf$e = ifelse(df$y==2 | df$y==3,1,0)\n\nkable(df)\n```\n\n::: {.cell-output-display}\n| id|  deb|  fin|  y| nseq|  e|\n|--:|----:|----:|--:|----:|--:|\n|  1| 2018| 2021|  1|    1|  0|\n|  1| 2022| 2024|  2|    2|  1|\n|  1| 2024| 2025|  1|    3|  0|\n|  2| 2019|   NA|  2|    1|  1|\n|  3| 2023| 2024|  3|    1|  1|\n|  3| 2024|   NA|  2|    2|  1|\n|  4| 2023|   NA|  1|    1|  0|\n:::\n:::\n\n\n\nDe nouveau l'utilisation d'un compteur sur cette variable indicatrice, peut s'avérer utile pour repérer le moment de l'occurence. \n\n\n\n::: {.cell}\n\n```{.r .cell-code  code-fold=\"true\" code-summary=\"Show the code\"}\ndf = df %>% group_by(id) %>% mutate(n  = cumsum(e)) \n\nkable(df)\n```\n\n::: {.cell-output-display}\n| id|  deb|  fin|  y| nseq|  e|  n|\n|--:|----:|----:|--:|----:|--:|--:|\n|  1| 2018| 2021|  1|    1|  0|  0|\n|  1| 2022| 2024|  2|    2|  1|  1|\n|  1| 2024| 2025|  1|    3|  0|  1|\n|  2| 2019|   NA|  2|    1|  1|  1|\n|  3| 2023| 2024|  3|    1|  1|  1|\n|  3| 2024|   NA|  2|    2|  1|  2|\n|  4| 2023|   NA|  1|    1|  0|  0|\n:::\n:::\n\n\n\nPour id=(2,3,4), ce compteur permet d'obtenir l'information souhaitée, à savoir n=0 en situation d'attente/séjour/survie et n=1 l'année de l'évènement. \nPour id=1 cependant, l'alternance en y=1 et y=(2,3) ne permet pas de récupérer l'année d'occurence (première fois en 2 ou 3). \nCela peut être fait, en faisant un compteur sur le compteur précédent: \n\n\n\n::: {.cell}\n\n```{.r .cell-code  code-fold=\"true\" code-summary=\"Show the code\"}\ndf = df %>% group_by(id) %>% mutate(nn  = cumsum(n)) \n\nkable(df)\n```\n\n::: {.cell-output-display}\n| id|  deb|  fin|  y| nseq|  e|  n| nn|\n|--:|----:|----:|--:|----:|--:|--:|--:|\n|  1| 2018| 2021|  1|    1|  0|  0|  0|\n|  1| 2022| 2024|  2|    2|  1|  1|  1|\n|  1| 2024| 2025|  1|    3|  0|  1|  2|\n|  2| 2019|   NA|  2|    1|  1|  1|  1|\n|  3| 2023| 2024|  3|    1|  1|  1|  1|\n|  3| 2024|   NA|  2|    2|  1|  2|  3|\n|  4| 2023|   NA|  1|    1|  0|  0|  0|\n:::\n:::\n\n\n\n**Récupération des information censurée**\n\nPour récupérer l'information sur les observations qui seront censurée, on peut faire un total sur la variable *n* ou *e*: si n=0, l'individu n'aura pas connu l'évènement.\n\n\n\n::: {.cell}\n\n```{.r .cell-code  code-fold=\"true\" code-summary=\"Show the code\"}\ndf = df %>% group_by(id) %>% mutate(N  = sum(n)) \n\nkable(df)\n```\n\n::: {.cell-output-display}\n| id|  deb|  fin|  y| nseq|  e|  n| nn|  N|\n|--:|----:|----:|--:|----:|--:|--:|--:|--:|\n|  1| 2018| 2021|  1|    1|  0|  0|  0|  2|\n|  1| 2022| 2024|  2|    2|  1|  1|  1|  2|\n|  1| 2024| 2025|  1|    3|  0|  1|  2|  2|\n|  2| 2019|   NA|  2|    1|  1|  1|  1|  1|\n|  3| 2023| 2024|  3|    1|  1|  1|  1|  3|\n|  3| 2024|   NA|  2|    2|  1|  2|  3|  3|\n|  4| 2023|   NA|  1|    1|  0|  0|  0|  0|\n:::\n:::\n\n\n\nPour id=4, N est bien égal à 0.\n\n**Récupération du début de l'exposition**\n\nLe début de l'exposition étant ici l'année de début de la première séquence. On peut facilement récupérer\ncette sur toute les lignes en la repérant (ici en générant une nouvelle variable avec la fonction `ifelse`), et en sommant sa valeur sur les autres lignes (=0).\n\n\n\n\n::: {.cell}\n\n```{.r .cell-code  code-fold=\"true\" code-summary=\"Show the code\"}\ndf$ debexp = ifelse(df$nseq==1, df$deb, 0)                    # <1>\n                    \ndf = df %>% group_by(id) %>% mutate(debexp  = sum(debexp))    # <2>\n\nkable(df)\n```\n\n::: {.cell-output-display}\n| id|  deb|  fin|  y| nseq|  e|  n| nn|  N| debexp|\n|--:|----:|----:|--:|----:|--:|--:|--:|--:|------:|\n|  1| 2018| 2021|  1|    1|  0|  0|  0|  2|   2018|\n|  1| 2022| 2024|  2|    2|  1|  1|  1|  2|   2018|\n|  1| 2024| 2025|  1|    3|  0|  1|  2|  2|   2018|\n|  2| 2019|   NA|  2|    1|  1|  1|  1|  1|   2019|\n|  3| 2023| 2024|  3|    1|  1|  1|  1|  3|   2023|\n|  3| 2024|   NA|  2|    2|  1|  2|  3|  3|   2023|\n|  4| 2023|   NA|  1|    1|  0|  0|  0|  0|   2023|\n:::\n:::\n\n\n\n1. La variable *debex* est égale à *deb* si *nseq=1*, 0 sinon.\n2. On somme cette valeur sur chaque individu pour l'ajouter aux séquences suivantes.\n\n\n**Mise en forme finale de la base**\n\nOn peut maintenant conserver les lignes qui nous intéresse à savoir celle où *nn=1* (évènement) ou *N=0* (censure).\n\n\n\n::: {.cell}\n\n```{.r .cell-code  code-fold=\"true\" code-summary=\"Show the code\"}\ndf = filter(df, nn==1 | N==0)\n\nkable(df)\n```\n\n::: {.cell-output-display}\n| id|  deb|  fin|  y| nseq|  e|  n| nn|  N| debexp|\n|--:|----:|----:|--:|----:|--:|--:|--:|--:|------:|\n|  1| 2022| 2024|  2|    2|  1|  1|  1|  2|   2018|\n|  2| 2019|   NA|  2|    1|  1|  1|  1|  1|   2019|\n|  3| 2023| 2024|  3|    1|  1|  1|  1|  3|   2023|\n|  4| 2023|   NA|  1|    1|  0|  0|  0|  0|   2023|\n:::\n:::\n\n\n\n\nOn dispose déjà de la variable d'évènement/censure (*e* ou *n* = (0,1), on finit donc par la \nvariable de durée.  \n\n\n\n::: {.cell}\n\n```{.r .cell-code  code-fold=\"true\" code-summary=\"Show the code\"}\ndf$fin[is.na(df$fin)] = 2025\n\ndf$dur = ifelse(df$e==1, df$deb - df$debexp + 1, df$fin - df$debexp + 1)\n\ndf = select(df, c(id,e,dur))\n\nkable(df)\n```\n\n::: {.cell-output-display}\n| id|  e| dur|\n|--:|--:|---:|\n|  1|  1|   5|\n|  2|  1|   1|\n|  3|  1|   1|\n|  4|  0|   3|\n:::\n:::\n\n\n\nCes informations sont suffisantes pour estimer une fonction de séjour et on peut ajouter, si elles ne sont pas présentes, des covariables fixes issues du fichier des caractéristiques générales. Pour l'ajout de covariables dynamiques, leur ajout n'est pas forcément difficile pour une analyse en durée discrète ^[En conservant l'information sur les années, on transformera la base en format individu-période et on procédera à une fusion des informations]. Pour les analyses type Cox, selon la nature de la variable dynamique, l'opération (quel que soit le logiciel utilisé) risque d'être plus ou moins compliquée.\n\n\n## Durée de séjour dans la séquence d'intérêt et variables d'analyse\n\nEn première ou deuxième analyse, on peut également voir s'intéresser à la durée de séjour dans l'état précédent. Par exemple, si l'analyse précédent consistait à regarder la durée de séjour dans le premier emploi, on pourrait regarder ensuite la durée jusqu'à sa reprise.\n\nCela va un peu (voir plus) se compliquer. On va repartir de la base de départ précédente en ajoutant une observation. \n\n\n\n\n::: {.cell}\n\n```{.r .cell-code  code-fold=\"true\" code-summary=\"Show the code\"}\ndf =  data.frame(id  =  c( 1, 1, 1, 2, 3, 3, 4, 5, 5, 5 , 5),\n                 deb =  c(2018, 2022, 2024, 2019, 2023, 2024, 2023, 2019, 2021, 2023, 2024),\n                 fin =  c(2021, 2024, 2025, NA, 2024, NA, NA, 2021, 2023, 2024, NA), \n                 y  =   c(1, 2, 1, 2, 3, 2, 1, 1, 2, 1,3),\n                 nseq = c(1, 2, 3, 1, 1, 2, 1, 1, 2, 3, 4)\n)\n\nkable(df)\n```\n\n::: {.cell-output-display}\n| id|  deb|  fin|  y| nseq|\n|--:|----:|----:|--:|----:|\n|  1| 2018| 2021|  1|    1|\n|  1| 2022| 2024|  2|    2|\n|  1| 2024| 2025|  1|    3|\n|  2| 2019|   NA|  2|    1|\n|  3| 2023| 2024|  3|    1|\n|  3| 2024|   NA|  2|    2|\n|  4| 2023|   NA|  1|    1|\n|  5| 2019| 2021|  1|    1|\n|  5| 2021| 2023|  2|    2|\n|  5| 2023| 2024|  1|    3|\n|  5| 2024|   NA|  3|    4|\n:::\n:::\n\n\n\n**Filtrage des observations hors champs** \n\nOn peut déjà supprimer les observations hors champs, à savoir ici id=4 qui n'a pas \nconnu l'évènement dont on analyse la durée.\n\n\n\n::: {.cell}\n\n```{.r .cell-code  code-fold=\"true\" code-summary=\"Show the code\"}\ndf$e23 = ifelse(df$y==2 | df$y==3,1,0)                       # <1>\n\ndf = df %>%  group_by(id) %>% mutate(n23  = cumsum(e23)) \ndf = filter(df, n23!=0)                                      # <2>\n\nkable(df)\n```\n\n::: {.cell-output-display}\n| id|  deb|  fin|  y| nseq| e23| n23|\n|--:|----:|----:|--:|----:|---:|---:|\n|  1| 2022| 2024|  2|    2|   1|   1|\n|  1| 2024| 2025|  1|    3|   0|   1|\n|  2| 2019|   NA|  2|    1|   1|   1|\n|  3| 2023| 2024|  3|    1|   1|   1|\n|  3| 2024|   NA|  2|    2|   1|   2|\n|  5| 2021| 2023|  2|    2|   1|   1|\n|  5| 2023| 2024|  1|    3|   0|   1|\n|  5| 2024|   NA|  3|    4|   1|   2|\n:::\n:::\n\n\n\n1. Nom de la variable *e23* pour repérer la présence de l'évènement dont on analyse la durée.\n2. Ce compteur est suffisant car l'observation n'a qu'une ligne.\n\n**Récupération de l'évènement analysé**\n\nIci l'évènement sera un *retour* dans l'état y=1. Il y a de nouveau une possibilité de censure à \ndroite si une observation reste dans l'état 2 ou 3 jusqu'au moment de l'enquête.\n\nIl peut être utile d'utiliser des variables décalées pour repérer les changements d'état d'une séquence à une autre. Ces décalages sont appelées *lead* ou *lag*:\n\n* ***lead***:  $x_t = x_{t+1}$\n* ***lag***:   $x_t = x_{t-1}$\n\nOn va utilise ici des ***lead*** et donc pouvoir repérer les changements d'état d'une séquence à une autre. Comme on s'intéresse au retour à l'état 1:\n\n\n\n\n::: {.cell}\n\n```{.r .cell-code  code-fold=\"true\" code-summary=\"Show the code\"}\ndf$e = ifelse(df$y==1,1,0)                                     # <1>\n\ndf = df %>%  group_by(id) %>% mutate(diff_e  = e - lead(e))    # <2>\n\nkable(df)\n```\n\n::: {.cell-output-display}\n| id|  deb|  fin|  y| nseq| e23| n23|  e| diff_e|\n|--:|----:|----:|--:|----:|---:|---:|--:|------:|\n|  1| 2022| 2024|  2|    2|   1|   1|  0|     -1|\n|  1| 2024| 2025|  1|    3|   0|   1|  1|     NA|\n|  2| 2019|   NA|  2|    1|   1|   1|  0|     NA|\n|  3| 2023| 2024|  3|    1|   1|   1|  0|      0|\n|  3| 2024|   NA|  2|    2|   1|   2|  0|     NA|\n|  5| 2021| 2023|  2|    2|   1|   1|  0|     -1|\n|  5| 2023| 2024|  1|    3|   0|   1|  1|      1|\n|  5| 2024|   NA|  3|    4|   1|   2|  0|     NA|\n:::\n:::\n\n\n\n1. *e* est une indicatrice qui repère l'état 1\n2. On fait *redescendre* la valeur de *e* sur la séquence précédente, et on calcule la difference.\n\nPour chaque dernière séquence la valeur du lag est une valeur manquante.\nOn repère l'évènement avec une valeur de -1 (transition de 0 à 1). On ne peut pas \nencore filtrer les informations car il va falloir récupérer la fin de la séquence, mais\non peut déjà construire l'information. \n\n\n\n::: {.cell}\n\n```{.r .cell-code  code-fold=\"true\" code-summary=\"Show the code\"}\ndf$e = ifelse(df$diff_e==-1,1,0)\ndf$e[is.na(df$e)] = 0\ndf = df %>%  group_by(id) %>% mutate(e  = sum(e)) \n\nkable(df)\n```\n\n::: {.cell-output-display}\n| id|  deb|  fin|  y| nseq| e23| n23|  e| diff_e|\n|--:|----:|----:|--:|----:|---:|---:|--:|------:|\n|  1| 2022| 2024|  2|    2|   1|   1|  1|     -1|\n|  1| 2024| 2025|  1|    3|   0|   1|  1|     NA|\n|  2| 2019|   NA|  2|    1|   1|   1|  0|     NA|\n|  3| 2023| 2024|  3|    1|   1|   1|  0|      0|\n|  3| 2024|   NA|  2|    2|   1|   2|  0|     NA|\n|  5| 2021| 2023|  2|    2|   1|   1|  1|     -1|\n|  5| 2023| 2024|  1|    3|   0|   1|  1|      1|\n|  5| 2024|   NA|  3|    4|   1|   2|  1|     NA|\n:::\n:::\n\n\n\n**Récupération de l'année final avec succesion d'états de même type**\n\nLa difficulté ici est apportée seulement par id=3. Jusqu'à 2025, on a successivement l'état 2 puis 3. Il va donc falloir récupérer cette dernière année de succession de 2 et 3, jusqu'à la censure ou jusqu'à un retour dans l'état 1.\nS'il n'y avait pas ce genre de situation, l'utilisation de la variable *diff_e* aurait été suffisante pour récupérer l'année de fin lorsqu'on a plusieurs séquences (situations pour id=1,5).\n\nOn va de nouveau utiliser un lead, mais sur la variable *e23*.\n\n\n\n::: {.cell}\n\n```{.r .cell-code  code-fold=\"true\" code-summary=\"Show the code\"}\ndf = select(df, -c(nseq, diff_e)) # <1>  \n\ndf = df %>%  group_by(id) %>% mutate(lead_e23 = lead(e23, n = 1, default = NA))  # <2>\n\ndf$idem = ifelse(df$e23 == df$lead_e23, 1, 0) # <3>\ndf$idem[is.na(df$idem)]=0\ndf = df %>%  group_by(id) %>% mutate(idem  = sum(idem)) # <4> \n\n\nkable(df)\n```\n\n::: {.cell-output-display}\n| id|  deb|  fin|  y| e23| n23|  e| lead_e23| idem|\n|--:|----:|----:|--:|---:|---:|--:|--------:|----:|\n|  1| 2022| 2024|  2|   1|   1|  1|        0|    0|\n|  1| 2024| 2025|  1|   0|   1|  1|       NA|    0|\n|  2| 2019|   NA|  2|   1|   1|  0|       NA|    0|\n|  3| 2023| 2024|  3|   1|   1|  0|        1|    1|\n|  3| 2024|   NA|  2|   1|   2|  0|       NA|    1|\n|  5| 2021| 2023|  2|   1|   1|  1|        0|    0|\n|  5| 2023| 2024|  1|   0|   1|  1|        1|    0|\n|  5| 2024|   NA|  3|   1|   2|  1|       NA|    0|\n:::\n:::\n\n\n\n1. On supprime les colonnes non utilisées pour gagner ici de la lisibilité\n2. *lead* sur la variable e23.\n3. La variable *idem* permet de repérer une suite d'état 2 et 3. On ne passe pas ici par une variable de différence (le faire par prudence si on le souhaite).\n4. Ici le total est égal à 1. Si on avait eu une séquence supplémentaire de 3, il serait égal à 2. L'important ici est de repérer la situation, soit 0 ou supérieur à 0.  \n\n\nOn doit maintenant récupérer la dernière année de fin des situations où idem>0, et la placer\nsur la première.\n\n\n\n::: {.cell}\n\n```{.r .cell-code  code-fold=\"true\" code-summary=\"Show the code\"}\ndf$fin[is.na(df$fin)] = 2025                # <1>\ndf$lead_e23[is.na(df$lead_e23)]   = -10     # <2>\n\ndf$truefin = ifelse((df$lead_e23 != df$e23) & df$idem>0, df$fin,0) # <3>\n\ndf = df %>% group_by(id) %>% mutate(truefin = sum(truefin))  # <4> \ndf$fin = ifelse(df$idem>0, df$truefin, df$fin)  # <4>\n\ndf = select(df, -c(y,e23,lead_e23,idem))\n\nkable(df)\n```\n\n::: {.cell-output-display}\n| id|  deb|  fin| n23|  e| truefin|\n|--:|----:|----:|---:|--:|-------:|\n|  1| 2022| 2024|   1|  1|       0|\n|  1| 2024| 2025|   1|  1|       0|\n|  2| 2019| 2025|   1|  0|       0|\n|  3| 2023| 2025|   1|  0|    2025|\n|  3| 2024| 2025|   2|  0|    2025|\n|  5| 2021| 2023|   1|  1|       0|\n|  5| 2023| 2024|   1|  1|       0|\n|  5| 2024| 2025|   2|  1|       0|\n:::\n:::\n\n\n\n1. On remplace l'année de la censure par sa valeur (important pour id=3).\n2. Pour régler un problème de gestion des NA avec `ifelse`. A tester avec `if_else` ou `case_when`.\n3. On recupère la valeur de l'année de fin lorsqu'il y a une succession d'états de même nature pour l'analyse.\n4. on remplace la valeur dans la variable *fin* en cas de succession seulement.\n\n\nOn peut [enfin] sélectionner et conserver une seule ligne par individu et générer la variable de durée\n\n\n\n::: {.cell}\n\n```{.r .cell-code  code-fold=\"true\" code-summary=\"Show the code\"}\ndf= select(df,-truefin)\n\ndf = df %>%  group_by(id) %>% mutate(nn23     = cumsum(n23)) \ndf = filter(df, n23==nn23)\n\ndf$dur= df$fin - df$deb + 1 \n\ndf = select(df, -c(n23,nn23))\n\nkable(df)\n```\n\n::: {.cell-output-display}\n| id|  deb|  fin|  e| dur|\n|--:|----:|----:|--:|---:|\n|  1| 2022| 2024|  1|   3|\n|  2| 2019| 2025|  0|   7|\n|  3| 2023| 2025|  0|   3|\n|  5| 2021| 2023|  1|   3|\n:::\n:::\n",
    "supporting": [
      "10-manipulation_files"
    ],
    "filters": [
      "rmarkdown/pagebreak.lua"
    ],
    "includes": {},
    "engineDependencies": {
      "knitr": [
        "{\"type\":\"list\",\"attributes\":{},\"value\":[]}"
      ]
    },
    "preserve": null,
    "postProcess": false
  }
}