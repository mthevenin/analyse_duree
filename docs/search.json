[
  {
    "objectID": "15-Sas.html",
    "href": "15-Sas.html",
    "title": "16  SAS",
    "section": "",
    "text": "17 Modèles paramétrique\nOn utilise la procédure proc lifereg et on indique le type de distribution\nproc lifereg data=trans;\nmodel stime*died(0) = year age surgery /D=WEIBULL;\nrun;\nproc lifereg data=trans;\nmodel stime*died(0) = year age surgery /D=LLOGISTIC;\nrun;"
  },
  {
    "objectID": "15-Sas.html#analyse-non-paramétrique",
    "href": "15-Sas.html#analyse-non-paramétrique",
    "title": "16  SAS",
    "section": "16.1 Analyse non paramétrique",
    "text": "16.1 Analyse non paramétrique\n\n16.1.1 Méthode actuarielle\nAvec une longueur d’intervalle fixe égale à 30 jours.\nLa durée médiane est donnée par la colonne résidual median time. Sur la première ligne, il s’agit de la durée médiane sur toutes les personnes exposées au risque. Dans les lignes suivante, cette durée médiane est recalculée pour les personnes restant exposées au risque dans chaque intervalle.\n\nproc lifetest data=trans method=lifetable width=30;\ntime stime*died(0);run;\n\n\n\n\n\n\n16.1.2 Méthode Kaplan-Meier\nLe tableau des estimateurs ne sera pas reporté (voir intro du document).\nPour récupérer ces estimateurs, on peut les récupérer via l’instruction output et les exporter, par exemple, dans un tableur.\n\nods exclude Lifetest.Stratum1.ProductLimitEstimates;\nproc lifetest data=trans;\ntime stime*died(0); run;\n\n\n\n\nWarning sur la durée moyenne reportée Sauf exception ne pas interpréter le tableau donnant la durée moyenne. Se reporter à l’estimation des RMST plus bas.\nComparaison des fonctions de survie\nTests du log rank\n\nods exclude Lifetest.Stratum1.ProductLimitEstimates Lifetest.Stratum2.ProductLimitEstimates ;\nproc lifetest data=trans;\ntime stime*died(0);\nstrata surgery / test=all;\nrun;\n\n\n\n\n\nComparaison des RMST\nDisponible avec le dernier module stat de Sas base (Sas-Stat 15.1 novembre 2018).\n\nods exclude Lifetest.Stratum1.ProductLimitEstimates;\nproc lifetest data=trans rmst plots=(rmst);\ntime stime*died(0);\nstrata surgery; run;"
  },
  {
    "objectID": "15-Sas.html#modèle-de-cox",
    "href": "15-Sas.html#modèle-de-cox",
    "title": "16  SAS",
    "section": "16.2 Modèle de Cox",
    "text": "16.2 Modèle de Cox\n\n16.2.1 Estimation du modèle\n\nproc phreg data=trans;\nmodel stime*died(0) = year age surgery ;\nrun;\n\n\n\n\n16.2.2 Tests de l’hypothèse PH\n\n16.2.2.1 Test de Grambsch Therneau\nDemande au moins l’avant dernière version de Sas/Stat (2016?).\nLe test est exécuté directement dans l’instruction phreg (ajouter zph). L’option global permet de récupérer le résultat du test omnibus (attention rejette facilement \\(H_0\\) - hypothèse PH respectée - lorsque le nombre de degrés de liberté est élevé).\n\nods select PHReg.zphTest;\nproc phreg data=trans zph(global noplot);\nmodel stime*died(0) = year age surgery ;\nrun;\n\n\nPar défaut SAS utilise la transformation \\(f(t)=t\\) (idem Stata). Pour obtenir l’option par défaut de R \\(f(t) = 1 - KM(t)\\):\n\nods select PHReg.zphTest;\nproc phreg data=trans zph(global noplot transform=km);\nmodel stime*died(0) = year age surgery ;\nrun;\n\n\n\n\n16.2.2.2 Interaction avec la durée\nEstimation d’un modèle avec indicatrices\nLa covariable doit être sous forme d’indicatrice (binaire: (0,1)). Ce qui est le cas ici avec la variable surgery.\nExemple avec une covariable X à 3 modalités codée 1,2,3.\nEstimation du modèle de Cox avec l’instruction class (ref: X=1)\n\nproc phreg data=base;\nclass X(ref=\"1\");\nmodel variable_dur*variable_cens(0) = X; run;\n\nEstimation du modèle de Cox avec indicatrices\n\ndata base; set base;\nX1 = X=1;\nX2 = X=2;\nX3 = X=3; run;\n\nproc phreg data=base;\nmodel variable_dur*variable_cens(0) = X2 X3; run;\n\nLa variable d’intéraction (\\(surgeryt = surgery\\times stime\\)) est générée, le temps de l’estimation après l’instruction model.\n\nods select PHReg.ParameterEstimates;\nproc phreg data=trans ;\nmodel stime*died(0) = year age surgery surgeryt ;\nsurgeryt = surgery*stime;\nrun;\n\n\n\n\n\n16.2.3 Variable dynamique\nWarning: opération en ‘aveugle’\nContrairement à R et Stata, la base n’a pas à être splittée, on ne peut pas vérifier si la variable dynamique a été correctement créée. La variable dynamique, qui peut être appréhendée comme une variable en intéraction avec la durée, est générée après l’instruction model.\n Ici la tvc prendra la valeur 1 lorsque stime&gt;wait, 0 sinon.\n\nods select PHReg.ParameterEstimates;\nproc phreg data=trans;\nmodel stime*died(0) = year age surgery tvc ;\ntvc = transplant=1 and stime&gt;=wait;\nrun;"
  },
  {
    "objectID": "15-Sas.html#modèle-à-temps-discret",
    "href": "15-Sas.html#modèle-à-temps-discret",
    "title": "16  SAS",
    "section": "16.3 Modèle à temps discret",
    "text": "16.3 Modèle à temps discret\n\n16.3.1 Mise en forme\nOn utilise une boucle pour répliquer les lignes sur la valeur de la durée. La nouvelle variable de durée (t) sous forme de compteur est générée automatiquement.\n\ndata td; set trans; \ndo t=1 to mois; \n     output; \n     end; run;\n     \ndata td; set td;\nif t&lt;mois then died=0;\nt2=t*t;\nt3=t2*t; run;\n\n\n\n16.3.2 Durée continue\nEstimation du modèle\n\nods select Logistic.FitStatistics;\nproc logistic data=td;\nmodel died(ref=\"0\") = t t2 t3 year age surgery  ; run;\n\n\n\n\n16.3.3 Durée discrète\nPour l’exemple on va regrouper la durée par ses quartiles. Pour chaque individu, on conserve seulement une observation dans chaque quartile.\n\nproc rank data=td out=td2 groups=4;\nvar t;\nranks tq4;\nrun;\n\ndata td2; set td2;\nid2=put(id, 3.);\ntq42=put(tq4, 1.);\ng=id2 || tq42; run;\n\nproc sort data=td2; by id tq4; run;\n\ndata td2; set td2;\nby g;\nif LAST.g; run;\n\nEstimation\n\nproc logistic data=td2;\nclass tq4 / param=ref;\nmodel died(ref=\"0\") = tq4 year age surgery; run;"
  },
  {
    "objectID": "15-Sas.html#risques-concurrents",
    "href": "15-Sas.html#risques-concurrents",
    "title": "16  SAS",
    "section": "16.5 Risques concurrents",
    "text": "16.5 Risques concurrents\n\n16.5.1 Non paramétrique\nOn indique en option la cause d’intérêt avec eventcode=valeur , les autres étant considérées commes des risques concurrents.\n\nproc lifetest data=trans plots=CIF;\ntime stime*compet(0) / eventcode=1; run;\n\n\n\n\nPour récupérer le test de Gray, on utilise l’instruction strata.\n\nproc lifetest data=trans plots=CIF;\ntime stime*compet(0) / eventcode=1\nstrata surgery; run;\n\n\n\n\n\n16.5.2 Modèle logistique multinomial à durée discrète\n\ndata td; set trans; \ndo t=1 to mois; \n     output; \n     end; \nrun;\ndata td; set td;\nif t&lt;mois then compet=0;\nt2=t*t\nrun;\n\n\nproc logistic data=td;\nmodel compet(ref=\"0\") = t t2 year age surgery / link=glogit;\nrun;"
  },
  {
    "objectID": "15-Sas.html#modèles-paramétrique",
    "href": "15-Sas.html#modèles-paramétrique",
    "title": "16  SAS",
    "section": "16.4 Modèles paramétrique",
    "text": "16.4 Modèles paramétrique\nOn utilise la procédure proc lifereg et on indique le type de distribution\n\nproc lifereg data=trans;\nmodel stime*died(0) = year age surgery /D=WEIBULL;\nrun;\n\n\n\n\nproc lifereg data=trans;\nmodel stime*died(0) = year age surgery /D=LLOGISTIC;\nrun;"
  }
]