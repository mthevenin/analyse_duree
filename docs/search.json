[
  {
    "objectID": "index.html",
    "href": "index.html",
    "title": "Introduction à l’analyse biographique des durées",
    "section": "",
    "text": "1 Présentation - Bibliographie - Outils"
  },
  {
    "objectID": "index.html#le-support",
    "href": "index.html#le-support",
    "title": "Introduction à l’analyse biographique des durées",
    "section": "Le support",
    "text": "Le support\nMISE A JOUR DU SUPPORT EN COURS\n\nLe support est maintenant intégralement disponible en format pdf en cliquant sur l’icône au dessus de la barre de recherche.\nD’ici la fin septembre 2023:\n\nUne introduction du support à cet endroit.\nQuelques ajouts:\n\nUn nouveau chapitre sur la manipulation des données [OK].\npar l’exemple, un gros warning sur des utilisations douteuses de données prospectives (on visera l’EDP - Echantillon Démographique Permanent).\nj’avais retiré la courte présentation des fonctions de lien probit et surtout complémentaire-loglog dans les modèles à durée discrète….maivaise idée que j’ai eu (voir point précédent).\nJe ne pense pas avoir le temps mais on sait jamais: une première présentation des modèles à pseudo observations dans la section annexe.\n\n\n\nVersion pdf:\n\nDernière maj: le 21 août 2023\nPour le chapitre programmation, seulement la section dédiée à R a été ajoutée. Pour les 3 autres applications, il n’y a qu’une version HTML."
  },
  {
    "objectID": "index.html#bibliographie-vf",
    "href": "index.html#bibliographie-vf",
    "title": "Introduction à l’analyse biographique des durées",
    "section": "Bibliographie vf",
    "text": "Bibliographie vf\nLes éléments bibliographiques qui figurent ci-dessous proviennent du champ des sciences sociales. Elle est courte, mais efficace. Quelle que soit la langue, le nombre de cours ou support sont très nombreux en médecine, qui est ici l’espace privilégié de l’ingénierie méthodologique. On trouve également de (trop) nombreux tutoriels à dominante mise en pratique avec R.\nAccès en ligne\n\nCours Gilbert Colletaz (Université d’Orléans - Master d’économétrie).\n\nLe cours est mis à jour tous les ans, applications uniquement avec Sas.\nDernière version 2020: lien\n\nDocument de travail de Simon Quantin (Insee).\n\nCouvre l’ensemble des techniques de base d’analyse des durées en durée dite continue. Il propose surement la meilleure introduction en langue française à la problématique de la fragilité.\nApplication en R seulement (attention au passage de la v3 du package survival)\n2019 - pas de mise à jour: lien\n\n\nOuvrage de référence en démographie:\nL’analyse démographique des biographies de Daniel Courgeau et Eva Lelièvre (Edition de l’Ined - 1989)."
  },
  {
    "objectID": "index.html#outils",
    "href": "index.html#outils",
    "title": "Introduction à l’analyse biographique des durées",
    "section": "Outils",
    "text": "Outils\n\nSupport réalisé sous Rstudio avec l’outil d’édition Quarto\nLangages utilisés pour la partie programmation:\n\nR\nStata v18\nSas\nPython"
  },
  {
    "objectID": "index.html#bibliographie",
    "href": "index.html#bibliographie",
    "title": "Introduction à l’analyse biographique des durées",
    "section": "Bibliographie",
    "text": "Bibliographie\nLes éléments bibliographiques qui figurent ci-dessous proviennent du champ des sciences sociales. Elle est courte, mais efficace. Quelle que soit la langue, le nombre de cours ou support sont très nombreux en médecine, qui est ici l’espace privilégié de l’ingénierie méthodologique. On trouve également de (trop) nombreux tutoriels à dominante mise en pratique avec R.\nAccès en ligne\n\nCours Gilbert Colletaz (Université d’Orléans - Master d’économétrie).\n\nLe cours est mis à jour tous les ans, applications uniquement avec Sas.\nDernière version 2020: lien\n\nDocument de travail de Simon Quantin (Insee).\n\nCouvre l’ensemble des techniques de base d’analyse des durées en durée dite continue. Il propose surement la meilleure introduction en langue française à la problématique de la fragilité.\nApplication en R seulement (attention au passage de la v3 du package survival)\n2019 - pas de mise à jour: lien\n\nLes notes de cours de German Rodriguez (en)\n\nDémographe à l’université de Princeton.\nLes dernières mises à jour doivent dater de 2017-2018: https://grodri.github.io/glms/notes/c7.pdf\n\n\nOuvrage de référence en démographie:\n\nL’analyse démographique des biographies de Daniel Courgeau et Eva Lelièvre (Edition de l’Ined - 1989). Malheureusement cet ouvrage ne dispose pas de version epub ou pdf disponible en ligne 1."
  },
  {
    "objectID": "index.html#footnotes",
    "href": "index.html#footnotes",
    "title": "Introduction à l’analyse biographique des durées",
    "section": "",
    "text": "pour les résident.e.s du campus condorcet, l’ouvrage est disponible au GED [lien]↩︎"
  },
  {
    "objectID": "10-manipulation.html#calcul-des-variables-danalyses",
    "href": "10-manipulation.html#calcul-des-variables-danalyses",
    "title": "11  Eléments de mise en forme des données",
    "section": "11.1 Calcul des variables d’analyses",
    "text": "11.1 Calcul des variables d’analyses\nConstruction de la base:\n\n\nCode\ndf = data.frame(id  =  c(1, 1, 1, 2),\n                deb =  c(2020, 2023, 2024, 2022),\n                fin =  c(2021, 2024, 2025, NA), \n                  x =  c(1,2,1,2))\nkable(df)\n\n\n\n\n\nid\ndeb\nfin\nx\n\n\n\n\n1\n2020\n2021\n1\n\n\n1\n2023\n2024\n2\n\n\n1\n2024\n2025\n1\n\n\n2\n2022\nNA\n2\n\n\n\n\n\nOn supposera que l’année de collecte, pour toutes les observations, est 2025 2.\nSi cela n’est pas donné dans le module biographique, il peut être intéressant de construire les numéros de séquences des trajectoires.\n\n\nCode\ndf$nseq = 1 \ndf = df %&gt;% group_by(id) %&gt;% mutate(nseq = cumsum(nseq))  \n\nkable(df)\n\n\n\n\n\nid\ndeb\nfin\nx\nnseq\n\n\n\n\n1\n2020\n2021\n1\n1\n\n\n1\n2023\n2024\n2\n2\n\n\n1\n2024\n2025\n1\n3\n\n\n2\n2022\nNA\n2\n1\n\n\n\n\n\nExemple 1 : durée de séjour de la première séquence observée\nSupposons que x traduit un type de relation/union, par exemple x=1 est une relation non cohabitante et x=2 est une relation cohabitante. On s’intéresse à la durée de la première relation, sans distinction entre 1 et 2. Il suffit de séléctionner la première séquence.\n\n\nCode\ndf = filter(df, nseq==1)\n\n\nLa variable de fin va permettre de repérer les informations censurées, et de générer la variable d’évènement. A ce niveau il est donc important de ne pas encore remplacer la date de censure par sa valeur.\n\nSi fin est une valeur manquante: observation censurée.\nSi fin est une valeur renseignée: occurence de l’évènement.\n\n\n\nCode\ndf$e = ifelse(is.na(df$fin), 0,1)\n\nkable(df)\n\n\n\n\n\nid\ndeb\nfin\nx\nnseq\ne\n\n\n\n\n1\n2020\n2021\n1\n1\n1\n\n\n2\n2022\nNA\n2\n1\n0\n\n\n\n\n\nPour la variable de durée 3, une repéré les observations censurées, elle est calculée directement avec les variables fin et deb.\n\n\nCode\ndf$dur = ifelse(df$e==1, df$fin - df$deb + 1, 2025 - df$deb + 1)\n\nkable(df)\n\n\n\n\n\nid\ndeb\nfin\nx\nnseq\ne\ndur\n\n\n\n\n1\n2020\n2021\n1\n1\n1\n2\n\n\n2\n2022\nNA\n2\n1\n0\n4\n\n\n\n\n\nExemple 2 : changement de métrique temporelle\nToujours avec le même exemple, mais en ajoutant une observation, supposons que l’on dispose également de l’information sur les mois. Sur les mois où l’évènement à eu lieu, mais également sur les mois où l’enquête a été réalisée.\n\n\nCode\ndf2 = data.frame(id  = c(1, 1, 1, 2,3),\n                deb  = c(2020, 2023, 2024, 2022, 2021),\n                debm = c(2,5,3,10,9),\n                fin  = c(2021, 2024, 2025, NA,2021), \n                finm = c(4,2,12,NA,11), \n                x    = c(1,2,1,2,1),\n                enq  = c(2025,2025,2025,2025,2025),\n                enqm = c(4,4,4,5,4))\n\ndf2$nseq = 1 \ndf2 = df2 %&gt;% group_by(id) %&gt;% mutate(nseq = cumsum(nseq))  \n\nkable(df2)\n\n\n\n\n\nid\ndeb\ndebm\nfin\nfinm\nx\nenq\nenqm\nnseq\n\n\n\n\n1\n2020\n2\n2021\n4\n1\n2025\n4\n1\n\n\n1\n2023\n5\n2024\n2\n2\n2025\n4\n2\n\n\n1\n2024\n3\n2025\n12\n1\n2025\n4\n3\n\n\n2\n2022\n10\nNA\nNA\n2\n2025\n5\n1\n\n\n3\n2021\n9\n2021\n11\n1\n2025\n4\n1\n\n\n\n\n\nOn remarque que la nouvelle observation (id=3) a connu l’évènement, ici la fin de la relation, la même année qu’au début d’exposition (le début de la relation)…. mais au bout de 2,6,11 mois???? Commeon dispose de l’information sur les mois de début et de fin cela peut être intéressant de l’exploite. De la même manière si l’enquête a été réalisée la même année, les entretiens n’ont pas eu lieu le même mois. On aura besoin de cette information pour les observations censurées.\nDe nouveau on sélectionne la première séquence, et pour la lisibilité de la base on retire les informations qui ne seront pas ou plus exploitées (nseq, x).\n\n\nCode\ndf2 = filter(df2,nseq==1)\ndf2 = select(df2, -c(x,nseq))\n\nkable(df2)\n\n\n\n\n\nid\ndeb\ndebm\nfin\nfinm\nenq\nenqm\n\n\n\n\n1\n2020\n2\n2021\n4\n2025\n4\n\n\n2\n2022\n10\nNA\nNA\n2025\n5\n\n\n3\n2021\n9\n2021\n11\n2025\n4\n\n\n\n\n\nOn génère la variable censure/évènement (toujours à faire avant la variable de durée) de la même manière que pour l’exemple 1.\n\n\nCode\ndf2$e = ifelse(is.na(df2$fin), 0, 1)\n\nkable(df2)\n\n\n\n\n\nid\ndeb\ndebm\nfin\nfinm\nenq\nenqm\ne\n\n\n\n\n1\n2020\n2\n2021\n4\n2025\n4\n1\n\n\n2\n2022\n10\nNA\nNA\n2025\n5\n0\n\n\n3\n2021\n9\n2021\n11\n2025\n4\n1\n\n\n\n\n\nPour la variable de durée, le principe est de multiplié par 12 la différence entre l’année de fin et l’année de début et d’ajouter la différence entre le mois de fin et le mois de début.\nPour les observations censurées, ici l’année de fin est identique mais les mois varient. En terme de programmation, surtout si avec R on utilise ifelse, il est préférable d’y aller doucement en créant une durée pour les observations qui ont connu l’évènement et une durée pour les observations censurées. Puis de regrouper les deux cas. C’est ce qui est fait dans le code qui suit.\nDurée selon les valeurs de e:\n\n\nCode\ndf2$dur1 = ifelse(df2$e==1, 12*(df2$fin - df2$deb) + (df2$finm - df2$debm),  0) \ndf2$dur0 = ifelse(df2$e==0, 12*(2025 - df2$deb)    + (df2$enqm  - df2$debm), 0) \n\nkable(df2)\n\n\n\n\n\nid\ndeb\ndebm\nfin\nfinm\nenq\nenqm\ne\ndur1\ndur0\n\n\n\n\n1\n2020\n2\n2021\n4\n2025\n4\n1\n14\n0\n\n\n2\n2022\n10\nNA\nNA\n2025\n5\n0\n0\n31\n\n\n3\n2021\n9\n2021\n11\n2025\n4\n1\n2\n0\n\n\n\n\n\nOn regroupe par simple sommation (le else étant 0).\n\n\nCode\ndf2$dur  = df2$dur1 + df2$dur0\n\ndf2 = select(df2, -c(dur1,dur0))\n\nkable(df2)\n\n\n\n\n\nid\ndeb\ndebm\nfin\nfinm\nenq\nenqm\ne\ndur\n\n\n\n\n1\n2020\n2\n2021\n4\n2025\n4\n1\n14\n\n\n2\n2022\n10\nNA\nNA\n2025\n5\n0\n31\n\n\n3\n2021\n9\n2021\n11\n2025\n4\n1\n2\n\n\n\n\n\nOn dispose ainsi des éléments nécessaire pour faire une analyse de durée avec une métrique mensuelle 4.\nExemple 3 : importation d’un début d’expositon externe\nOn repart de la première base\n\n\n\n\n\nid\ndeb\nfin\nx\nnseq\n\n\n\n\n1\n2020\n2021\n1\n1\n\n\n1\n2023\n2024\n2\n2\n\n\n1\n2024\n2025\n1\n3\n\n\n2\n2022\nNA\n2\n1\n\n\n\n\n\nOn suppose maintenant que x traduit des situations sur le marché du travail. Par exemple x=1 est un emploi en CDD et x=2 un emploi en CDI. On s’intéresse à la durée entre la fin des études et le premier emploi, quel que soit sont type.\n\nOn ne dispose pas ici de toutes l’information pour calculer la durée, soit la fin des études. Elle peut être donnée dans une base classique regroupant l’ensemble des caractéristiques individuelles de type fixe (année de naissance, sexe…).\nComme on s’intéresse à la durée de recherche du premier emploi, dans le module biographique la date de début va devenir la date de fin.\nPour les observations présente dans la base biographique, il n’y a pas de censure à droite. Mais si on regarde le fichier des caractéristiques générales, fixe:\n\n\n\nCode\netude = data.frame(id = c(1,2,3), fin_etude = c(2020,2021,2023))\nkable(etude)\n\n\n\n\n\nid\nfin_etude\n\n\n\n\n1\n2020\n\n\n2\n2021\n\n\n3\n2023\n\n\n\n\n\nUne nouvelle observation (id=3) apparaît. Au moment de l’enquête, elle n’a pas (encore) trouvé un emploi depuis la fin de ces études. On a donc une observation qui sera censurée.\n\n\n\n\n\n\nNote\n\n\n\nCertaines bases biographiques peuvent être structurées avec des trajectoires strictement continue, l’année (l’âge) de fin étant l’année (l’âge) de début de la trajectoire suivante. Dans ce cas, l’information serait immédiatement disponible, avec la présence d’un nombre de séquences plus important dans la base.\n\n\nOn va devoir:\n\nSélectionner la première sequence d’emploi dans la base df (variable nseq).\nLa fusionner avec la base étude.\n\nAvant la fusion, on peut conserver seulement les informations nécessaires (id, deb). La variable deb va changer également de statut en devenant l’année de fin de la période de recherche d’emploi.\n\n\nCode\ndf = filter(df, nseq==1)\ndf = select(df, -c(fin,x,nseq))\n\ndf = rename(df, fin = deb)\nkable(df)\n\n\n\n\n\nid\nfin\n\n\n\n\n1\n2020\n\n\n2\n2022\n\n\n\n\n\nAprès la fusion:\n\n\nCode\ndf = full_join(etude, df,  by = c('id'))\n\ndf = rename(df, deb = fin_etude)\n\nkable(df)\n\n\n\n\n\nid\ndeb\nfin\n\n\n\n\n1\n2020\n2020\n\n\n2\n2021\n2022\n\n\n3\n2023\nNA\n\n\n\n\n\nOn a toutes les informations pour générer la variable censure/évènement et la variable de durée:\n\n\nCode\ndf$e = ifelse(is.na(df$fin),0,1)\n\ndf$dur = ifelse(df$e, df$fin - df$deb + 1, 2025 - df$deb + 1)\nkable(df)\n\n\n\n\n\nid\ndeb\nfin\ne\ndur\n\n\n\n\n1\n2020\n2020\n1\n1\n\n\n2\n2021\n2022\n1\n2\n\n\n3\n2023\nNA\n0\n3"
  },
  {
    "objectID": "10-manipulation.html#appariement-de-modules-biographiques",
    "href": "10-manipulation.html#appariement-de-modules-biographiques",
    "title": "11  Eléments de mise en forme des données",
    "section": "11.2 Appariement de modules biographiques",
    "text": "11.2 Appariement de modules biographiques\nOn repart de la première base, avec les numéros de séquence.\n\n\n\n\n\nid\ndeb\nfin\nx\nnseq\n\n\n\n\n1\n2020\n2021\n1\n1\n\n\n1\n2023\n2024\n2\n2\n\n\n1\n2024\n2025\n1\n3\n\n\n2\n2022\nNA\n2\n1\n\n\n\n\n\n\n11.2.1 Mise en forme d’une base\nPour apparier des informations de plusieurs modules biographiques, on doit transformer les bases en format individus-séquences en format individus-périodes (ici individus années).\n\nEtape 1: allongement sur chaque séquence après avoir générées leur durée\nEtape 2: générer une variable de période (année) sur chaque ligne. Elle servira pour l’appariement.\n\nPourquoi ne pas utiliser la simple différence entre la fin et le début ?\nDurée (fin - début) et allongement de la base:\nOn ne génère pas des variables d’analyse, on aurait besoin de l’information sur l’année de l’enquête pour les informations censurées.\n\n\nCode\ndf$fin[is.na(df$fin)] = 2025\n\nkable(df)\n\n\n\n\n\nid\ndeb\nfin\nx\nnseq\n\n\n\n\n1\n2020\n2021\n1\n1\n\n\n1\n2023\n2024\n2\n2\n\n\n1\n2024\n2025\n1\n3\n\n\n2\n2022\n2025\n2\n1\n\n\n\n\n\nAllongement de la base:\n\n\nCode\ndf1 = df\ndf1$dur1 = df1$fin - df1$deb\n\ndf1$dur1b = df1$dur1 # uncount supprime la variable d'origine \ndf1 = uncount(df1,dur1b)\n\nkable(df1)\n\n\n\n\n\nid\ndeb\nfin\nx\nnseq\ndur1\n\n\n\n\n1\n2020\n2021\n1\n1\n1\n\n\n1\n2023\n2024\n2\n2\n1\n\n\n1\n2024\n2025\n1\n3\n1\n\n\n2\n2022\n2025\n2\n1\n3\n\n\n2\n2022\n2025\n2\n1\n3\n\n\n2\n2022\n2025\n2\n1\n3\n\n\n\n\n\nPour générer la variable période (année), on a besoin d’un compteur qui sera associé à la variable deb. On doit bien contrôler l’opération par identifiant et numéro de séquence.\n\n\nCode\ndf1$c = 1\ndf1 = df1 %&gt;% group_by(id,nseq) %&gt;% mutate(year = deb  + cumsum(c)) \n\nkable(df1)\n\n\n\n\n\nid\ndeb\nfin\nx\nnseq\ndur1\nc\nyear\n\n\n\n\n1\n2020\n2021\n1\n1\n1\n1\n2021\n\n\n1\n2023\n2024\n2\n2\n1\n1\n2024\n\n\n1\n2024\n2025\n1\n3\n1\n1\n2025\n\n\n2\n2022\n2025\n2\n1\n3\n1\n2023\n\n\n2\n2022\n2025\n2\n1\n3\n1\n2024\n\n\n2\n2022\n2025\n2\n1\n3\n1\n2025\n\n\n\n\n\nProblème: les années de début ne sont pas correncte: 2021 au lieu de 2020 pour la première séquence de id=1 par exemple.\n\n\n\n\n\n\nImportant\n\n\n\nOn doit donc impérativement augmenter la différence entre la fin et le début par +1 pour que l’ensemble des périodes (années) soit couvertes.\n\n\nOn reprend donc les opérations précédentes mais avec durée = fin - debut + 1\n\nAllongement de la base avec durée augmentée\n\n\n\nCode\ndf2 = df\ndf2$dur2 = df2$fin - df2$deb + 1\n\ndf2$dur2b = df2$dur2 # uncount supprime la variable d'origine \ndf2 = uncount(df2,dur2b)\n\nkable(df2)\n\n\n\n\n\nid\ndeb\nfin\nx\nnseq\ndur2\n\n\n\n\n1\n2020\n2021\n1\n1\n2\n\n\n1\n2020\n2021\n1\n1\n2\n\n\n1\n2023\n2024\n2\n2\n2\n\n\n1\n2023\n2024\n2\n2\n2\n\n\n1\n2024\n2025\n1\n3\n2\n\n\n1\n2024\n2025\n1\n3\n2\n\n\n2\n2022\n2025\n2\n1\n4\n\n\n2\n2022\n2025\n2\n1\n4\n\n\n2\n2022\n2025\n2\n1\n4\n\n\n2\n2022\n2025\n2\n1\n4\n\n\n\n\n\n\nCréation de la variable year: sur chaque individus-séquences, la somme entre le compteur et l’année de début doit être réduite de 11.\n\n\n\nCode\ndf2$c = 1\ndf2 = df2 %&gt;% group_by(id,nseq) %&gt;% mutate(year = deb  + cumsum(c) - 1)\n\ndf2 = select(df2, -c(deb,fin,dur2))\n\n\nkable(df2)\n\n\n\n\n\nid\nx\nnseq\nc\nyear\n\n\n\n\n1\n1\n1\n1\n2020\n\n\n1\n1\n1\n1\n2021\n\n\n1\n2\n2\n1\n2023\n\n\n1\n2\n2\n1\n2024\n\n\n1\n1\n3\n1\n2024\n\n\n1\n1\n3\n1\n2025\n\n\n2\n2\n1\n1\n2022\n\n\n2\n2\n1\n1\n2023\n\n\n2\n2\n1\n1\n2024\n\n\n2\n2\n1\n1\n2025\n\n\n\n\n\nLes années sont toutes couvertes….mais un peu trop. En effet, lorsque les trajectoires sont continues soit lorsque l’année de fin d’une séquence est identique à l’année de début de la suivante, les années vont être doublonnées. On doit dont supprimer ce doublon.\n\nSuppression des doublons des trajectoires continues.\n\nDe nouveaux on doit faire un choix, soit on priviligie l’année de fin, soit on privilégie l’année de début. Les applications ont des fonctions qui permettent de supprimer les doublons5. On peut le faire manuellement en regardant pour chaque personnes-années le nombre de doublon. Cela se fait facilement à l’aide d’un compteur, ici la variable nyear.\n\n\nCode\ndf2 = df2 %&gt;% group_by(id,year) %&gt;% mutate(nyear = cumsum(c))\n\nkable(df2)\n\n\n\n\n\nid\nx\nnseq\nc\nyear\nnyear\n\n\n\n\n1\n1\n1\n1\n2020\n1\n\n\n1\n1\n1\n1\n2021\n1\n\n\n1\n2\n2\n1\n2023\n1\n\n\n1\n2\n2\n1\n2024\n1\n\n\n1\n1\n3\n1\n2024\n2\n\n\n1\n1\n3\n1\n2025\n1\n\n\n2\n2\n1\n1\n2022\n1\n\n\n2\n2\n1\n1\n2023\n1\n\n\n2\n2\n1\n1\n2024\n1\n\n\n2\n2\n1\n1\n2025\n1\n\n\n\n\n\nSi on souhaite garder l’année de fin on filtre les observations en conservant celles dont nyear=1. Si on souhaite privilégier les années de début on foltre les observations en conservant celles dont nyear=2. Si on souhaite conserver les années de fin de séquence:\n\n\nCode\ndf2 = filter(df2, nyear==1)\n\ndf2 = select(df2, -c(nseq,c,nyear))\n\nkable(df2)\n\n\n\n\n\nid\nx\nyear\n\n\n\n\n1\n1\n2020\n\n\n1\n1\n2021\n\n\n1\n2\n2023\n\n\n1\n2\n2024\n\n\n1\n1\n2025\n\n\n2\n2\n2022\n\n\n2\n2\n2023\n\n\n2\n2\n2024\n\n\n2\n2\n2025\n\n\n\n\n\n\n\n\n\n\n\nEn résumé\n\n\n\n\nA la date (année/âge) de censure remplacer la valeur manquante par sa valeur. Si ultérieurement on a besoin de garder l’information sur la censure - valeur manquante - , on peut générer une variable mirroir de fin.\nSur chaque séquence calculer la durée avec une augmentation de +1.\nCréer une variable période (année) sur chaque ligne. Elle servira à définir la clé d’appariement.\nSupprimer les doublons sur les transition continue \\(fin_t = debut_{t+1}\\).\n\n\n\n\n\n11.2.2 Fusion des informations biographiques\n\n11.2.2.1 Fusion avec l’ensemble des périodes observables\nPour commencer par un exemple plutôt simple, on note que pour id=1 l’année 2022 n’est pas renseignée (trajectoire non continue). Si on reprend un exemple précédent (relations de couple), cette année pourrait être identifiée comme une période sans relation. Une façon simple de boucher ce type “trous”, est d’utiliser les années de naissances des individus, et de créer une base individus-périodes qui couvre toutes les années de vie de l’individu jusqu’à l’enquête. On remontera jusque là, mais on va par exemple considérer que pour id=1 et id=2 ce début de tout est en 2018.\n\n\nCode\ndftout = data.frame(id  =  c(1, 2),\n                    t0  =  c(2018, 2018))\n\nkable(dftout)    \n\n\n\n\n\nid\nt0\n\n\n\n\n1\n2018\n\n\n2\n2018\n\n\n\n\n\n\nOn ajoute l’information sur l’année de l’enquête (2025).\nOn génère la durée\nOn allonge la base\nOn génère la variable année sur chaque ligne (on contrôle seulement sur id)\n\n\n\nCode\ndftout$tmax = 2025\n\ndftout$dur  = dftout$tmax - dftout$t0 + 1\n\ndftout = uncount(dftout,dur)\n\n\ndftout$c = 1\ndftout = dftout %&gt;% group_by(id) %&gt;% mutate(year = t0  + cumsum(c) - 1)\n\ndftout = select(dftout, -c(t0,tmax,c))\n\nkable(dftout)    \n\n\n\n\n\nid\nyear\n\n\n\n\n1\n2018\n\n\n1\n2019\n\n\n1\n2020\n\n\n1\n2021\n\n\n1\n2022\n\n\n1\n2023\n\n\n1\n2024\n\n\n1\n2025\n\n\n2\n2018\n\n\n2\n2019\n\n\n2\n2020\n\n\n2\n2021\n\n\n2\n2022\n\n\n2\n2023\n\n\n2\n2024\n\n\n2\n2025\n\n\n\n\n\nOn peut maintenant apparier cette couverture de toutes les années de vie jusqu’à l’enquête à la base biographique:\n\n\nCode\ndf2 = full_join(df2, dftout, by = c(\"id\",\"year\"))\n\ndf2 = arrange(df2, id, year)\nkable(df2)    \n\n\n\n\n\nid\nx\nyear\n\n\n\n\n1\nNA\n2018\n\n\n1\nNA\n2019\n\n\n1\n1\n2020\n\n\n1\n1\n2021\n\n\n1\nNA\n2022\n\n\n1\n2\n2023\n\n\n1\n2\n2024\n\n\n1\n1\n2025\n\n\n2\nNA\n2018\n\n\n2\nNA\n2019\n\n\n2\nNA\n2020\n\n\n2\nNA\n2021\n\n\n2\n2\n2022\n\n\n2\n2\n2023\n\n\n2\n2\n2024\n\n\n2\n2\n2025\n\n\n\n\n\nPour supprimer les informations qui précèdent la première séquence de la biographie, on peut générer un compteur sur la variable x après avoir remplacer ses valeurs manquantes par des 0. On gardera les lignes pour lesquels ce compteur est supérieur à 1.\n\n\nCode\ndf2$x[is.na(df2$x)] = 0\n\ndf2 = df2 %&gt;% group_by(id) %&gt;% mutate(nx = cumsum(x))\n\nkable(df2)    \n\n\n\n\n\nid\nx\nyear\nnx\n\n\n\n\n1\n0\n2018\n0\n\n\n1\n0\n2019\n0\n\n\n1\n1\n2020\n1\n\n\n1\n1\n2021\n2\n\n\n1\n0\n2022\n2\n\n\n1\n2\n2023\n4\n\n\n1\n2\n2024\n6\n\n\n1\n1\n2025\n7\n\n\n2\n0\n2018\n0\n\n\n2\n0\n2019\n0\n\n\n2\n0\n2020\n0\n\n\n2\n0\n2021\n0\n\n\n2\n2\n2022\n2\n\n\n2\n2\n2023\n4\n\n\n2\n2\n2024\n6\n\n\n2\n2\n2025\n8\n\n\n\n\n\nOn supprime les lignes lorsque nx=0.\n\n\nCode\ndf2 = filter(df2, nx&gt;0)\n\ndf2 = select(df2, -c(nx))\n\nkable(df2)    \n\n\n\n\n\nid\nx\nyear\n\n\n\n\n1\n1\n2020\n\n\n1\n1\n2021\n\n\n1\n0\n2022\n\n\n1\n2\n2023\n\n\n1\n2\n2024\n\n\n1\n1\n2025\n\n\n2\n2\n2022\n\n\n2\n2\n2023\n\n\n2\n2\n2024\n\n\n2\n2\n2025\n\n\n\n\n\n\n\n11.2.2.2 Fusion avec une autre base biographique\nOn peut être amené à fusionner plusieurs modules biographique. Jusqu’à présent, une même année, tous les individus ne pouvaient être que dans une situation, par exemple une seul emploi, un seul lieu de résidence etc… Pour certains phénomènes, une même années ou pendant une période plus longue on peut observer simultanément plusieurs états différent, ou plus classiquement observer une somme d’un même état. On parle ici d’overlapping. Ce type de situation est typiquement celle qu’on observe avec le nombre d’enfants.\nSupposons que le base ci-dessous traduit la naissance et potentiellement le décès des enfants.\n\n\nCode\ndfy = data.frame(id  =  c(1, 2, 2),\n                deb =  c(2022, 2019, 2023),\n                fin =  c(NA, 2024,NA), \n                nseq =  c(1,1,2))\n\nkable(dfy)\n\n\n\n\n\nid\ndeb\nfin\nnseq\n\n\n\n\n1\n2022\nNA\n1\n\n\n2\n2019\n2024\n1\n\n\n2\n2023\nNA\n2\n\n\n\n\n\n\nid=1 a un premier enfant en 2022 qui est toujours en vie au moment de l’enquête (2025)\nid=2:\n\nA un premier enfant en 2019 qui décède en 2024\nA un second enfant en 2023, toujours en vie au moment de l’enquête\nDe la naissance du second enfant au décès du premier, on va donc avoir des doublons (overlapping) sur les années\n\n\nSi on reprend les manipulations précédentes jusqu’à la création de la variable year:\n\n\nCode\ndfy$fin[is.na(dfy$fin)] = 2025\ndfy$dur = dfy$fin - dfy$deb + 1\n\ndfy$durb = dfy$dur  # Uncount supprime la variable d'origine \ndfy = uncount(dfy,durb)\n\ndfy$c = 1\ndfy = dfy %&gt;% group_by(id,nseq) %&gt;% mutate(year = deb  + cumsum(c) - 1)\n\n\nLa variable year est bien renseignée 2 fois pour les années 2023 et 2024.\nOn peut s’intéresser au fait d’avoir ou non un enfant, ou de manière plus générale au nombre d’enfant. En créant cette information, on se donne également le moyen de corriger cet overlapping:\n\nOn peut de nouveau générer un compteur contrôlé par individu année\nEn génerant un total de ligne doublonnée, on récupèrera par exemple ici le nombre d’enfant en vie chaque année.\nEn ne gardant que la ligne ou le compteur est égal à 1, on supprime les doublons tout en gardant l’information sur le nombre d’enfant en vie une année donnée.\n\n\n\nCode\ndfy = dfy %&gt;% group_by(id,year) %&gt;% mutate(ny = cumsum(c))\ndfy = dfy %&gt;% group_by(id,year) %&gt;% mutate(tot_y =  sum(c))\n\nkable(dfy)\n\n\n\n\n\nid\ndeb\nfin\nnseq\ndur\nc\nyear\nny\ntot_y\n\n\n\n\n1\n2022\n2025\n1\n4\n1\n2022\n1\n1\n\n\n1\n2022\n2025\n1\n4\n1\n2023\n1\n1\n\n\n1\n2022\n2025\n1\n4\n1\n2024\n1\n1\n\n\n1\n2022\n2025\n1\n4\n1\n2025\n1\n1\n\n\n2\n2019\n2024\n1\n6\n1\n2019\n1\n1\n\n\n2\n2019\n2024\n1\n6\n1\n2020\n1\n1\n\n\n2\n2019\n2024\n1\n6\n1\n2021\n1\n1\n\n\n2\n2019\n2024\n1\n6\n1\n2022\n1\n1\n\n\n2\n2019\n2024\n1\n6\n1\n2023\n1\n2\n\n\n2\n2019\n2024\n1\n6\n1\n2024\n1\n2\n\n\n2\n2023\n2025\n2\n3\n1\n2023\n2\n2\n\n\n2\n2023\n2025\n2\n3\n1\n2024\n2\n2\n\n\n2\n2023\n2025\n2\n3\n1\n2025\n1\n1\n\n\n\n\n\nIl ne reste plus qu’à supprimer les lignes où ny&gt;1\n\n\nCode\ndfy = filter(dfy, ny==1)\ndfy = select(dfy, -c(ny,deb, fin, dur, nseq, c))\n\nkable(dfy)\n\n\n\n\n\nid\nyear\ntot_y\n\n\n\n\n1\n2022\n1\n\n\n1\n2023\n1\n\n\n1\n2024\n1\n\n\n1\n2025\n1\n\n\n2\n2019\n1\n\n\n2\n2020\n1\n\n\n2\n2021\n1\n\n\n2\n2022\n1\n\n\n2\n2023\n2\n\n\n2\n2024\n2\n\n\n2\n2025\n1\n\n\n\n\n\nAvec une ligne par année, on peut la fusionner avec une autre base biographique en format individus-années (même principe qu’avec la fusion avec la base sur toutes les années de vie).\n\n\nCode\ndf2y = full_join(dfy, df2, by = c(\"id\",\"year\"))\n\ndf2y = arrange(df2y, id,year)\n\ndf2y = select(df2y, c(id,year,x,tot_y))\n\ndf2y$tot_y[is.na(df2y$tot_y)] = 0\ndf2y$x[is.na(df2y$x)]   = 0\n\nkable(df2y)\n\n\n\n\n\nid\nyear\nx\ntot_y\n\n\n\n\n1\n2020\n1\n0\n\n\n1\n2021\n1\n0\n\n\n1\n2022\n0\n1\n\n\n1\n2023\n2\n1\n\n\n1\n2024\n2\n1\n\n\n1\n2025\n1\n1\n\n\n2\n2019\n0\n1\n\n\n2\n2020\n0\n1\n\n\n2\n2021\n0\n1\n\n\n2\n2022\n2\n1\n\n\n2\n2023\n2\n2\n\n\n2\n2024\n2\n2\n\n\n2\n2025\n2\n1"
  },
  {
    "objectID": "10-manipulation.html#sélection-dun-type-de-séquence-et-mise-en-forme-pour-lanalyse",
    "href": "10-manipulation.html#sélection-dun-type-de-séquence-et-mise-en-forme-pour-lanalyse",
    "title": "11  Eléments de mise en forme des données",
    "section": "11.3 Sélection d’un type de séquence et mise en forme pour l’analyse",
    "text": "11.3 Sélection d’un type de séquence et mise en forme pour l’analyse"
  },
  {
    "objectID": "10-manipulation.html#durée-jusquà-la-première-séquence",
    "href": "10-manipulation.html#durée-jusquà-la-première-séquence",
    "title": "11  Eléments de mise en forme des données",
    "section": "11.4 Durée jusqu’à la première séquence",
    "text": "11.4 Durée jusqu’à la première séquence\n\n\nCode\ndf =  data.frame(id  =  c( 1, 1, 1, 2, 3, 3, 4),\n                 deb =  c(2018, 2022, 2024, 2019, 2023, 2024, 2023),\n                 fin =  c(2021, 2024, 2025, NA, 2024, NA, NA), \n                 y  =   c(1, 2, 1, 2, 3, 2, 1),\n                 nseq = c(1, 2, 3, 1, 1, 2, 1)\n                 )\n\nkable(df)\n\n\n\n\n\nid\ndeb\nfin\ny\nnseq\n\n\n\n\n1\n2018\n2021\n1\n1\n\n\n1\n2022\n2024\n2\n2\n\n\n1\n2024\n2025\n1\n3\n\n\n2\n2019\nNA\n2\n1\n\n\n3\n2023\n2024\n3\n1\n\n\n3\n2024\nNA\n2\n2\n\n\n4\n2023\nNA\n1\n1\n\n\n\n\n\nOn va s’intéresser à la durée jusqu’à l’occurence de la séquence de type 2 ou 3 (variable y). On considéra que le début de l’exposition est donné par la variable deb sur la première séquence.\n\nid=1: début de l’exposition/observation en 2018, observe l’évènement en 2022.\nid=2: début de l’exposition/observation en 2019, observe l’évènement la même année.\nid=3: début de l’exposition/observation en 2019, observe l’évènement la même année.\nid=4: début de l’exposition/observation en 2023, n’a pas connu l’évènement au moment de l’enquête.\n\nRecupération de l’année de l’évènement\nOn peut repérer la présence d’une des deux séquences d’intérêt avec une indicatrice.\n\n\nCode\ndf$e = ifelse(df$y==2 | df$y==3,1,0)\n\nkable(df)\n\n\n\n\n\nid\ndeb\nfin\ny\nnseq\ne\n\n\n\n\n1\n2018\n2021\n1\n1\n0\n\n\n1\n2022\n2024\n2\n2\n1\n\n\n1\n2024\n2025\n1\n3\n0\n\n\n2\n2019\nNA\n2\n1\n1\n\n\n3\n2023\n2024\n3\n1\n1\n\n\n3\n2024\nNA\n2\n2\n1\n\n\n4\n2023\nNA\n1\n1\n0\n\n\n\n\n\nDe nouveau l’utilisation d’un compteur sur cette variable indicatrice, peut s’avérer utile pour repérer le moment de l’occurence.\n\n\nCode\ndf = df %&gt;% group_by(id) %&gt;% mutate(n  = cumsum(e)) \n\nkable(df)\n\n\n\n\n\nid\ndeb\nfin\ny\nnseq\ne\nn\n\n\n\n\n1\n2018\n2021\n1\n1\n0\n0\n\n\n1\n2022\n2024\n2\n2\n1\n1\n\n\n1\n2024\n2025\n1\n3\n0\n1\n\n\n2\n2019\nNA\n2\n1\n1\n1\n\n\n3\n2023\n2024\n3\n1\n1\n1\n\n\n3\n2024\nNA\n2\n2\n1\n2\n\n\n4\n2023\nNA\n1\n1\n0\n0\n\n\n\n\n\nPour id=(2,3,4), ce compteur permet d’obtenir l’information souhaitée, à savoir n=0 en situation d’attente/séjour/survie et n=1 l’année de l’évènement. Pour id=1 cependant, l’alternance en y=1 et y=(2,3) ne permet pas de récupérer l’année d’occurence (première fois en 2 ou 3). Cela peut être fait, en faisant un compteur sur le compteur précédent:\n\n\nCode\ndf = df %&gt;% group_by(id) %&gt;% mutate(nn  = cumsum(n)) \n\nkable(df)\n\n\n\n\n\nid\ndeb\nfin\ny\nnseq\ne\nn\nnn\n\n\n\n\n1\n2018\n2021\n1\n1\n0\n0\n0\n\n\n1\n2022\n2024\n2\n2\n1\n1\n1\n\n\n1\n2024\n2025\n1\n3\n0\n1\n2\n\n\n2\n2019\nNA\n2\n1\n1\n1\n1\n\n\n3\n2023\n2024\n3\n1\n1\n1\n1\n\n\n3\n2024\nNA\n2\n2\n1\n2\n3\n\n\n4\n2023\nNA\n1\n1\n0\n0\n0\n\n\n\n\n\nRécupération des information censurée\nPour récupérer l’information sur les observations qui seront censurée, on peut faire un total sur la variable n ou e: si n=0, l’individu n’aura pas connu l’évènement.\n\n\nCode\ndf = df %&gt;% group_by(id) %&gt;% mutate(N  = sum(n)) \n\nkable(df)\n\n\n\n\n\nid\ndeb\nfin\ny\nnseq\ne\nn\nnn\nN\n\n\n\n\n1\n2018\n2021\n1\n1\n0\n0\n0\n2\n\n\n1\n2022\n2024\n2\n2\n1\n1\n1\n2\n\n\n1\n2024\n2025\n1\n3\n0\n1\n2\n2\n\n\n2\n2019\nNA\n2\n1\n1\n1\n1\n1\n\n\n3\n2023\n2024\n3\n1\n1\n1\n1\n3\n\n\n3\n2024\nNA\n2\n2\n1\n2\n3\n3\n\n\n4\n2023\nNA\n1\n1\n0\n0\n0\n0\n\n\n\n\n\nPour id=4, N est bien égal à 0.\nRécupération du début de l’exposition\nLe début de l’exposition étant ici l’année de début de la première séquence. On peut facilement récupérer cette sur toute les lignes en la repérant (ici en générant une nouvelle variable avec la fonction ifelse), et en sommant sa valeur sur les autres lignes (=0).\n\n\nCode\n1df$ debexp = ifelse(df$nseq==1, df$deb, 0)\n                    \n2df = df %&gt;% group_by(id) %&gt;% mutate(debexp  = sum(debexp))\n\nkable(df)\n\n\n\n1\n\nLa variable debex est égale à deb si nseq=1, 0 sinon.\n\n2\n\nOn somme cette valeur sur chaque individu pour l’ajouter aux séquences suivantes.\n\n\n\n\n\n\n\nid\ndeb\nfin\ny\nnseq\ne\nn\nnn\nN\ndebexp\n\n\n\n\n1\n2018\n2021\n1\n1\n0\n0\n0\n2\n2018\n\n\n1\n2022\n2024\n2\n2\n1\n1\n1\n2\n2018\n\n\n1\n2024\n2025\n1\n3\n0\n1\n2\n2\n2018\n\n\n2\n2019\nNA\n2\n1\n1\n1\n1\n1\n2019\n\n\n3\n2023\n2024\n3\n1\n1\n1\n1\n3\n2023\n\n\n3\n2024\nNA\n2\n2\n1\n2\n3\n3\n2023\n\n\n4\n2023\nNA\n1\n1\n0\n0\n0\n0\n2023\n\n\n\n\n\nMise en forme finale de la base\nOn peut maintenant conserver les lignes qui nous intéresse à savoir celle où nn=1 (évènement) ou N=0 (censure).\n\n\nCode\ndf = filter(df, nn==1 | N==0)\n\nkable(df)\n\n\n\n\n\nid\ndeb\nfin\ny\nnseq\ne\nn\nnn\nN\ndebexp\n\n\n\n\n1\n2022\n2024\n2\n2\n1\n1\n1\n2\n2018\n\n\n2\n2019\nNA\n2\n1\n1\n1\n1\n1\n2019\n\n\n3\n2023\n2024\n3\n1\n1\n1\n1\n3\n2023\n\n\n4\n2023\nNA\n1\n1\n0\n0\n0\n0\n2023\n\n\n\n\n\nOn dispose déjà de la variable d’évènement/censure (e ou n = (0,1), on finit donc par la variable de durée.\n\n\nCode\ndf$fin[is.na(df$fin)] = 2025\n\ndf$dur = ifelse(df$e==1, df$deb - df$debexp + 1, df$fin - df$debexp + 1)\n\ndf = select(df, c(id,e,dur))\n\nkable(df)\n\n\n\n\n\nid\ne\ndur\n\n\n\n\n1\n1\n5\n\n\n2\n1\n1\n\n\n3\n1\n1\n\n\n4\n0\n3\n\n\n\n\n\nCes informations sont suffisantes pour estimer une fonction de séjour et on peut ajouter, si elles ne sont pas présentes, des covariables fixes issues du fichier des caractéristiques générales. Pour l’ajout de covariables dynamiques, leur ajout n’est pas forcément difficile pour une analyse en durée discrète 6. Pour les analyses type Cox, selon la nature de la variable dynamique, l’opération (quel que soit le logiciel utilisé) risque d’être plus ou moins compliquée."
  },
  {
    "objectID": "10-manipulation.html#durée-de-séjour-dans-la-séquence-dintérêt-et-variables-danalyse",
    "href": "10-manipulation.html#durée-de-séjour-dans-la-séquence-dintérêt-et-variables-danalyse",
    "title": "11  Eléments de mise en forme des données",
    "section": "11.5 Durée de séjour dans la séquence d’intérêt et variables d’analyse",
    "text": "11.5 Durée de séjour dans la séquence d’intérêt et variables d’analyse\nEn première ou deuxième analyse, on peut également voir s’intéresser à la durée de séjour dans l’état précédent. Par exemple, si l’analyse précédent consistait à regarder la durée de séjour dans le premier emploi, on pourrait regarder ensuite la durée jusqu’à sa reprise.\nCela va un peu (voir plus) se compliquer. On va repartir de la base de départ précédente en ajoutant une observation.\n\n\nCode\ndf =  data.frame(id  =  c( 1, 1, 1, 2, 3, 3, 4, 5, 5, 5 , 5),\n                 deb =  c(2018, 2022, 2024, 2019, 2023, 2024, 2023, 2019, 2021, 2023, 2024),\n                 fin =  c(2021, 2024, 2025, NA, 2024, NA, NA, 2021, 2023, 2024, NA), \n                 y  =   c(1, 2, 1, 2, 3, 2, 1, 1, 2, 1,3),\n                 nseq = c(1, 2, 3, 1, 1, 2, 1, 1, 2, 3, 4)\n)\n\nkable(df)\n\n\n\n\n\nid\ndeb\nfin\ny\nnseq\n\n\n\n\n1\n2018\n2021\n1\n1\n\n\n1\n2022\n2024\n2\n2\n\n\n1\n2024\n2025\n1\n3\n\n\n2\n2019\nNA\n2\n1\n\n\n3\n2023\n2024\n3\n1\n\n\n3\n2024\nNA\n2\n2\n\n\n4\n2023\nNA\n1\n1\n\n\n5\n2019\n2021\n1\n1\n\n\n5\n2021\n2023\n2\n2\n\n\n5\n2023\n2024\n1\n3\n\n\n5\n2024\nNA\n3\n4\n\n\n\n\n\nFiltrage des observations hors champs\nOn peut déjà supprimer les observations hors champs, à savoir ici id=4 qui n’a pas connu l’évènement dont on analyse la durée.\n\n\nCode\n1df$e23 = ifelse(df$y==2 | df$y==3,1,0)\n\ndf = df %&gt;%  group_by(id) %&gt;% mutate(n23  = cumsum(e23)) \n2df = filter(df, n23!=0)\n\nkable(df)\n\n\n\n1\n\nNom de la variable e23 pour repérer la présence de l’évènement dont on analyse la durée.\n\n2\n\nCe compteur est suffisant car l’observation n’a qu’une ligne.\n\n\n\n\n\n\n\nid\ndeb\nfin\ny\nnseq\ne23\nn23\n\n\n\n\n1\n2022\n2024\n2\n2\n1\n1\n\n\n1\n2024\n2025\n1\n3\n0\n1\n\n\n2\n2019\nNA\n2\n1\n1\n1\n\n\n3\n2023\n2024\n3\n1\n1\n1\n\n\n3\n2024\nNA\n2\n2\n1\n2\n\n\n5\n2021\n2023\n2\n2\n1\n1\n\n\n5\n2023\n2024\n1\n3\n0\n1\n\n\n5\n2024\nNA\n3\n4\n1\n2\n\n\n\n\n\nRécupération de l’évènement analysé\nIci l’évènement sera un retour dans l’état y=1. Il y a de nouveau une possibilité de censure à droite si une observation reste dans l’état 2 ou 3 jusqu’au moment de l’enquête.\nIl peut être utile d’utiliser des variables décalées pour repérer les changements d’état d’une séquence à une autre. Ces décalages sont appelées lead ou lag:\n\nlead: \\(x_t = x_{t+1}\\)\nlag: \\(x_t = x_{t-1}\\)\n\nOn va utilise ici des lead et donc pouvoir repérer les changements d’état d’une séquence à une autre. Comme on s’intéresse au retour à l’état 1:\n\n\nCode\n1df$e = ifelse(df$y==1,1,0)\n\n2df = df %&gt;%  group_by(id) %&gt;% mutate(diff_e  = e - lead(e))\n\nkable(df)\n\n\n\n1\n\ne est une indicatrice qui repère l’état 1\n\n2\n\nOn fait redescendre la valeur de e sur la séquence précédente, et on calcule la difference.\n\n\n\n\n\n\n\nid\ndeb\nfin\ny\nnseq\ne23\nn23\ne\ndiff_e\n\n\n\n\n1\n2022\n2024\n2\n2\n1\n1\n0\n-1\n\n\n1\n2024\n2025\n1\n3\n0\n1\n1\nNA\n\n\n2\n2019\nNA\n2\n1\n1\n1\n0\nNA\n\n\n3\n2023\n2024\n3\n1\n1\n1\n0\n0\n\n\n3\n2024\nNA\n2\n2\n1\n2\n0\nNA\n\n\n5\n2021\n2023\n2\n2\n1\n1\n0\n-1\n\n\n5\n2023\n2024\n1\n3\n0\n1\n1\n1\n\n\n5\n2024\nNA\n3\n4\n1\n2\n0\nNA\n\n\n\n\n\nPour chaque dernière séquence la valeur du lag est une valeur manquante. On repère l’évènement avec une valeur de -1 (transition de 0 à 1). On ne peut pas encore filtrer les informations car il va falloir récupérer la fin de la séquence, mais on peut déjà construire l’information.\n\n\nCode\ndf$e = ifelse(df$diff_e==-1,1,0)\ndf$e[is.na(df$e)] = 0\ndf = df %&gt;%  group_by(id) %&gt;% mutate(e  = sum(e)) \n\nkable(df)\n\n\n\n\n\nid\ndeb\nfin\ny\nnseq\ne23\nn23\ne\ndiff_e\n\n\n\n\n1\n2022\n2024\n2\n2\n1\n1\n1\n-1\n\n\n1\n2024\n2025\n1\n3\n0\n1\n1\nNA\n\n\n2\n2019\nNA\n2\n1\n1\n1\n0\nNA\n\n\n3\n2023\n2024\n3\n1\n1\n1\n0\n0\n\n\n3\n2024\nNA\n2\n2\n1\n2\n0\nNA\n\n\n5\n2021\n2023\n2\n2\n1\n1\n1\n-1\n\n\n5\n2023\n2024\n1\n3\n0\n1\n1\n1\n\n\n5\n2024\nNA\n3\n4\n1\n2\n1\nNA\n\n\n\n\n\nRécupération de l’année final avec succesion d’états de même type\nLa difficulté ici est apportée seulement par id=3. Jusqu’à 2025, on a successivement l’état 2 puis 3. Il va donc falloir récupérer cette dernière année de succession de 2 et 3, jusqu’à la censure ou jusqu’à un retour dans l’état 1. S’il n’y avait pas ce genre de situation, l’utilisation de la variable diff_e aurait été suffisante pour récupérer l’année de fin lorsqu’on a plusieurs séquences (situations pour id=1,5).\nOn va de nouveau utiliser un lead, mais sur la variable e23.\n\n\nCode\n1df = select(df, -c(nseq, diff_e))\n\n2df = df %&gt;%  group_by(id) %&gt;% mutate(lead_e23 = lead(e23, n = 1, default = NA))\n\n3df$idem = ifelse(df$e23 == df$lead_e23, 1, 0)\ndf$idem[is.na(df$idem)]=0\n4df = df %&gt;%  group_by(id) %&gt;% mutate(idem  = sum(idem))\n\n\nkable(df)\n\n\n\n1\n\nOn supprime les colonnes non utilisées pour gagner ici de la lisibilité\n\n2\n\nlead sur la variable e23.\n\n3\n\nLa variable idem permet de repérer une suite d’état 2 et 3. On ne passe pas ici par une variable de différence (le faire par prudence si on le souhaite).\n\n4\n\nIci le total est égal à 1. Si on avait eu une séquence supplémentaire de 3, il serait égal à 2. L’important ici est de repérer la situation, soit 0 ou supérieur à 0.\n\n\n\n\n\n\n\nid\ndeb\nfin\ny\ne23\nn23\ne\nlead_e23\nidem\n\n\n\n\n1\n2022\n2024\n2\n1\n1\n1\n0\n0\n\n\n1\n2024\n2025\n1\n0\n1\n1\nNA\n0\n\n\n2\n2019\nNA\n2\n1\n1\n0\nNA\n0\n\n\n3\n2023\n2024\n3\n1\n1\n0\n1\n1\n\n\n3\n2024\nNA\n2\n1\n2\n0\nNA\n1\n\n\n5\n2021\n2023\n2\n1\n1\n1\n0\n0\n\n\n5\n2023\n2024\n1\n0\n1\n1\n1\n0\n\n\n5\n2024\nNA\n3\n1\n2\n1\nNA\n0\n\n\n\n\n\nOn doit maintenant récupérer la dernière année de fin des situations où idem&gt;0, et la placer sur la première.\n\n\nCode\n1df$fin[is.na(df$fin)] = 2025\n2df$lead_e23[is.na(df$lead_e23)]   = -10\n\n3df$truefin = ifelse((df$lead_e23 != df$e23) & df$idem&gt;0, df$fin,0)\n\n4df = df %&gt;% group_by(id) %&gt;% mutate(truefin = sum(truefin))\ndf$fin = ifelse(df$idem&gt;0, df$truefin, df$fin)\n\ndf = select(df, -c(y,e23,lead_e23,idem))\n\nkable(df)\n\n\n\n1\n\nOn remplace l’année de la censure par sa valeur (important pour id=3).\n\n2\n\nPour régler un problème de gestion des NA avec ifelse. A tester avec if_else ou case_when.\n\n3\n\nOn recupère la valeur de l’année de fin lorsqu’il y a une succession d’états de même nature pour l’analyse.\n\n4\n\non remplace la valeur dans la variable fin en cas de succession seulement.\n\n\n\n\n\n\n\nid\ndeb\nfin\nn23\ne\ntruefin\n\n\n\n\n1\n2022\n2024\n1\n1\n0\n\n\n1\n2024\n2025\n1\n1\n0\n\n\n2\n2019\n2025\n1\n0\n0\n\n\n3\n2023\n2025\n1\n0\n2025\n\n\n3\n2024\n2025\n2\n0\n2025\n\n\n5\n2021\n2023\n1\n1\n0\n\n\n5\n2023\n2024\n1\n1\n0\n\n\n5\n2024\n2025\n2\n1\n0\n\n\n\n\n\nOn peut [enfin] sélectionner et conserver une seule ligne par individu et générer la variable de durée\n\n\nCode\ndf= select(df,-truefin)\n\ndf = df %&gt;%  group_by(id) %&gt;% mutate(nn23     = cumsum(n23)) \ndf = filter(df, n23==nn23)\n\ndf$dur= df$fin - df$deb + 1 \n\ndf = select(df, -c(n23,nn23))\n\nkable(df)\n\n\n\n\n\nid\ndeb\nfin\ne\ndur\n\n\n\n\n1\n2022\n2024\n1\n3\n\n\n2\n2019\n2025\n0\n7\n\n\n3\n2023\n2025\n0\n3\n\n\n5\n2021\n2023\n1\n3"
  },
  {
    "objectID": "10-manipulation.html#footnotes",
    "href": "10-manipulation.html#footnotes",
    "title": "11  Eléments de mise en forme des données",
    "section": "",
    "text": "Des éléments de manipulation/programmation pour un exemple volontairement très compliqué sont donnés dans méthodes =&gt; notes méthodologiques. Ayant été fait en 2015, le code pour R est largement out of date↩︎\nIci on a une enquête réalisée une même année pour toute les observations, ce n’est pas toujours le cas. De même au lieu de l’année, si les datations avaient été données par l’âge, au moment de l’enquête l’âge varierait d’une personne à une autre. Ces datations différentes (année ou âge) peuvent être présentes dans chaque module biographique d’une enquête, ou dans le fichier des caractéristiques fixes. Dans ce cas l’information devra être récupérée↩︎\nLa mesure est ici discrète/groupée, il me semble toujours préférable d’allonger les durées à +1. On démarre donc toujours un premier janvier pour terminer un 31 décembre sur l’information est donnée par des année. Ici t=1 représente la première année après la sortie des études. Une personne qui aura eu un emploi durant cette année, l’aura eu durant cette première année, que ce soit 2 semaines après ou 11 mois après. Si on disposait des mois, cela pourrait être intéressant de modifier cette métrique temporelle. Voir exemple 3↩︎\nContrairement au durée annuelle je n’ai pas ajouté 1 à chaque durée, ce qui est de nouveau envisageable par exemple si on veut explicitement indiquer les évènements qui ont lieu le premier mois. Pour id=3 la relation a t-elle durée du 1er septembre au 30 novembre, ou du 30 septembre au 1er novembre?? On a toujours un problème de précision, mais ici d’une trentaine de jours↩︎\navec R par exemple la fonction unique de dplyr↩︎\nEn conservant l’information sur les années, on transformera la base en format individu-période et on procédera à une fusion des informations↩︎"
  },
  {
    "objectID": "11-concurrent.html#problématique",
    "href": "11-concurrent.html#problématique",
    "title": "12  Risques concurrents",
    "section": "12.1 Problématique",
    "text": "12.1 Problématique\nOn étudie un processus dont l’occurence a plusieurs modalités, types ou causes:\n\nLa mortalité par cause de décès, les types de sortie du chômage: formation, emploi, radiation.\nLes types de sortie de l’emploi: chômage, longue maladie, sortie du marché du travail hors retraite.\nLes lieux de migration ou les espaces de mobilité résidentielle\nLes types de rupture d’union: séparation-divorce, veuvage).\n\nRappel: Déjà abordé dans la partie théorie, avec un recueil de données de type prospectif les “perdu.e.s de vue” peuvent difficilement être assimilés à des sorties d’observation non informatives (censures).\nL’analyse des risques concurrents est un cas particulier des modèles multi-états avec différents risques considérés comme absorbants.\nEn présence de risques concurrents, l’estimation de Kaplan-Meier ne peut se faire que sous l’hypothèse d’indépendance entre chacun des risques. Sinon l’estimateur de Kaplan-Meier n’est plus une probabilité. Une estimation de type KM d’un évènement en concurrence avec d’autres impose que ces derniers soient traités comme des censures à droites non informatives. Mais il n’est pas possible de tester cette hypothèse."
  },
  {
    "objectID": "11-concurrent.html#risques-cause-specific-et-biais-sur-les-estimateurs-km",
    "href": "11-concurrent.html#risques-cause-specific-et-biais-sur-les-estimateurs-km",
    "title": "12  Risques concurrents",
    "section": "12.2 Risques cause-specific et biais sur les estimateurs KM",
    "text": "12.2 Risques cause-specific et biais sur les estimateurs KM\nSi les risques ne sont pas indépendants les uns par rapport aux autres, la somme des estimateurs de (1-KM) pour chaque risque n’est pas égale - elle est supérieure - à l’estimateur de (1-KM) où les risques concurrents sont regroupés en un évènement unique. Par exemple les décès si on analyse ses causes.\nLe risque calculé en considérant les risques concurrents comme des censures à droite est appelé “cause-specific risk.\nCause specific risk\nPour le risque de type \\(k\\), le risque cause-spécific en \\(t_i\\) est égal à:\n\\[h_k(t_i)=\\frac{d_{i,k}}{R_i}\\] Où \\(d_{i,k}\\) est le nombre d’évènement de type \\(k\\) survenu en \\(t_i\\) et \\(R_i\\) la population soumise en \\(t_i\\).\n Conséquence: si les risques ne sont pas indépendants, la fonction de survie estimée avec la méthode Kaplan Meier n’exprime plus une probabilité.\nExemple sur les décès causés par une malformation cardiaque\nDans la base d’origine, il n’y a pas directement cette dimension de risque concurrent, même si on trouve dans la littérature médicale des études prenant le décès rapide post greffe comme un risque de ce type. Les données étant assez anciennes, avec beaucoup de décès post-opératoire, je ne me suis pas « risquer » à générer directement un risque concurrent sur cette information. Une sortie concurrente a donc été simulée sans plus de précision (variable compet), que l’on considèrera non strictement indépendante à la cause d’intérêt. Ce risque entre donc en concurrence avec la cause du décès directement liée à la malformation cardiaque, que la personne ait été transplantée ou non.\n\n\n\n           |    Survival Status\n           |       (1=dead) \n    compet |         0          1 |     Total\n-----------+----------------------+----------\n         0 |        28          0 |        28 \n         1 |         0         56 |        56 \n         2 |         0         19 |        19 \n-----------+----------------------+----------\n     Total |        28         75 |       103 \n\n\nVariable compet:\ncause 1 =&gt; décès directement provoquer par la malformation: compet=1 cause 2 =&gt; autre cause compet=0 =&gt; censure à droite\nLorsqu’on a analysé le décès par la méthode KM, la proportion de survivant.e.s était de 15%.\nSi on applique la méthode de Kaplan Meier à la cause 1 en traitant la cause 2 comme une censure à droite (\\(n=18+29=48\\)), puis en sommant les deux estimateurs, la fonction de répartition excède 100% au bout de 1000 jours environs. La proportion de survivant.e.s est donc négative.\n\n\n\nFonction de répartition avec une cause concurrente traitée comme une censure à droite"
  },
  {
    "objectID": "11-concurrent.html#estimations-en-présence-de-risques-concurrents-cif",
    "href": "11-concurrent.html#estimations-en-présence-de-risques-concurrents-cif",
    "title": "12  Risques concurrents",
    "section": "12.3 Estimations en présence de risques concurrents (CIF)",
    "text": "12.3 Estimations en présence de risques concurrents (CIF)\n\n12.3.1 Estimation non paramétrique\n\nUtiliser l’estimateur de Nelson Aalen: il s’agit du risque instantané cumulé. Comme il ne s’agit pas d’une probabilité, il a été longtemps utilisé comme mesure de l’incidence en présence de risques concurrents dans une logique dite cause specific.\n\n\\[H_k (t_i)=\\sum_{t_i\\leq t}\\left(\\frac{e_{i,k}}{n_i}\\right) \\]\n\nActuellement, l’estimateur le plus utilisé est la fonction dite d’incidence cumulée - CIF- de Kalbfleisch-Prentice et Marubini-Valscchi:\n\nIl repose sur une probabilité tout en supportant la non indépendance des risques.\nSon interprétation est identique à la fonction de répartition \\(F(t)=1-S(t)\\). Cette fonction est donc croissante.\nIl est possible de tester les différences entres CIF: test de Gray (R, SAS) ou test de Pepe-Mori (Stata).\n\n\nCIF (Cumulative Incidence Function)\n\nSi \\(h_k(t_i)\\) est le risque cause-spécific en \\(t_i\\) et \\(S(t_i-1)\\) l’estimateur de Kaplan-Meier en \\(t_i-1\\) lorsque tous les risques sont regroupés en un évènement unique, l’incidence cumulée pour le risque \\(k\\) en \\(t_i\\) est égale à:\n\n\\[IC_k(t_i)= \\sum_{t_i\\leq t}S(t_i-1)h_k(t_i)\\]\n\nLes valeurs prises par cette fonction pour la cause \\(k\\) ne dépendent donc pas seulement des individus ayant observé l’évènement à partir de cette seule cause, mais aussi du nombre de personnes qui n’ont pas encore observés l’évènement à partir des autres causes identifiées. Cette dernière information est donnée par \\(S(t_i-1)\\).\nL’incidence cumulée peut ainsi s’interpréter, simplement, comme la proportion d’individus qui sont sortis du risque jusqu’en \\(t_i\\) en raison de la cause \\(k\\).\n\n\n\n\nRisques concurrent: estimation de la CIF\n\n\n\n\n\n            failure:  compet == 1\n competing failures:  compet == 2\n\n    Time       CIF         SE     [95% Conf. Int.]\n--------------------------------------------------\n       1    0.0097     0.0097     0.0009    0.0477\n       2    0.0388     0.0190     0.0127    0.0892\n       3    0.0583     0.0231     0.0239    0.1149\n       5    0.0777     0.0264     0.0363    0.1395\n       6    0.0874     0.0278     0.0429    0.1515\n       8    0.0971     0.0292     0.0497    0.1634\n       9    0.1068     0.0304     0.0566    0.1751\n      12    0.1166     0.0316     0.0638    0.1868\n      16    0.1362     0.0338     0.0785    0.2099\n      18    0.1461     0.0349     0.0860    0.2212\n\n\n      21    0.1657     0.0367     0.1014    0.2437\n      32    0.1756     0.0376     0.1093    0.2550\n      37    0.1856     0.0384     0.1173    0.2662\n      40    0.1957     0.0393     0.1254    0.2775\n      43    0.2058     0.0400     0.1337    0.2888\n      45    0.2158     0.0408     0.1420    0.2999\n      50    0.2259     0.0415     0.1503    0.3110\n      51    0.2360     0.0422     0.1588    0.3221\n      53    0.2461     0.0428     0.1673    0.3330\n      58    0.2562     0.0434     0.1759    0.3439\n      61    0.2662     0.0440     0.1845    0.3548\n      66    0.2763     0.0445     0.1932    0.3656\n      69    0.2864     0.0450     0.2020    0.3763\n      72    0.3066     0.0459     0.2197    0.3976\n      77    0.3167     0.0464     0.2286    0.4082\n      78    0.3267     0.0467     0.2376    0.4187\n      81    0.3368     0.0471     0.2466    0.4292\n      85    0.3469     0.0475     0.2556    0.4396\n      90    0.3570     0.0478     0.2648    0.4500\n      96    0.3671     0.0481     0.2739    0.4604\n     102    0.3771     0.0484     0.2831    0.4707\n     110    0.3874     0.0487     0.2925    0.4812\n     149    0.3980     0.0489     0.3021    0.4920\n     165    0.4085     0.0492     0.3118    0.5027\n     186    0.4193     0.0495     0.3217    0.5137\n     188    0.4301     0.0497     0.3316    0.5246\n     207    0.4408     0.0499     0.3417    0.5354\n     219    0.4516     0.0501     0.3517    0.5462\n     263    0.4624     0.0502     0.3618    0.5570\n     285    0.4846     0.0505     0.3826    0.5791\n     308    0.4957     0.0506     0.3931    0.5900\n     340    0.5068     0.0507     0.4037    0.6009\n     583    0.5221     0.0514     0.4171    0.6168\n     675    0.5401     0.0524     0.4322    0.6361\n     733    0.5580     0.0532     0.4477    0.6548\n     995    0.5808     0.0548     0.4659    0.6795\n    1032    0.6036     0.0559     0.4851    0.7031\n    1386    0.6340     0.0583     0.5083    0.7357\n\n\n            failure:  compet == 2\n competing failures:  compet == 1\n\n    Time       CIF         SE     [95% Conf. Int.]\n--------------------------------------------------\n       3    0.0097     0.0097     0.0009    0.0477\n       6    0.0194     0.0136     0.0038    0.0619\n      16    0.0292     0.0166     0.0079    0.0761\n      17    0.0391     0.0191     0.0128    0.0897\n      28    0.0489     0.0213     0.0182    0.1029\n      30    0.0587     0.0232     0.0240    0.1157\n      35    0.0686     0.0250     0.0302    0.1286\n      36    0.0786     0.0267     0.0367    0.1411\n      39    0.0885     0.0282     0.0435    0.1534\n      40    0.0986     0.0296     0.0504    0.1658\n      68    0.1188     0.0322     0.0650    0.1901\n      80    0.1288     0.0334     0.0724    0.2020\n     100    0.1389     0.0345     0.0800    0.2138\n     153    0.1495     0.0356     0.0880    0.2261\n     334    0.1605     0.0368     0.0964    0.2392\n     342    0.1720     0.0381     0.1052    0.2526\n     852    0.1913     0.0417     0.1175    0.2787\n     979    0.2141     0.0460     0.1320    0.3094\n\n\nEn présence du risque concurrent, et traité comme tel, la moitié des personnes sont décédées suite à la malformation cardiaque au bout de 308 jours (200 jours avec une estimation de type « cause specific »).\nOn peut vérifier que la somme des estimateurs permet d’obtenir la survie toutes causes confondues. Il n’y a pas de surprise à cela, dans l’estimateur Marubini-Valscchi la survie d’ensemble intervient comme un facteur de pondération du quotient d’intensité dite « cause-specific ».\n\n\n\n\n\n\nR-Stata-Sas-Python\n\n\n\nL’estimation avec des risques de type « cause-specific » demande juste de recoder la variable évènement/censure, en glissant les risques concurrents en censure à droite.\nPour l’estimation des CIF (risque de sous répartition):\n\nR: la librairie cmprsk permet d’estimer simplement les incidences cumulées avec la fonction cuminc.\nSas: maintenant directement estimable avec proc lifetest. Il suffit d’indiquer le ou les risques d’intérêt dans l’instruction indiquant la variable de durée et de censure avec l’option failcode=valeur.\nStata: Estimation avec la commande externe stcompet. La commande génère des variables qui demande des manipulations supplémentaires pour afficher les résultats sous forme de tableau par exemple. On peut utiliser et préférer la commande externe stcomlist.\nPython: le wrapper de R (cmprsk) ne fonctionne plus à ce jour à défaut de mise à jour [2022].\n\n\n\n\n\n12.3.2 Compararaison des CIF\n\nTest d’homogénéité de Gray: est basé sur une autre mesure du risque en évènement concurrent. Sur le principe, identique à la philosopjie des test du logrank. Il s’agit du « subdistribution risks (« risque de sous-répartition », A.Latouche). Son interprétation n’est pas aisée car les personnes ayant observé un risque concurrent sont remises dans le Risk Set. Mais il est directement lié à l’estimation des CIF. Disponible avec SAS et R. Il est également sensible l’hypothèse de proportionnalité et à la distribution des censures à droites entre les groupes comparés. A ma connaissance il n’y a pas de variantes pondérées.\nTest de Pepe & Mori: teste directement deux courbes d’incidences et seulement 2. Je n’ai pas le recul nécessaire sur cette alternative, qui n’est implémenté que dans Stata.\n\n\nTest de Gray pour la variable surgery\n\n\nRisques\nChi2\nP&gt;Chi2\n\n\n\n\nCause1\n5.783\n0.0161\n\n\nCause2\n0.129\n0.7191\n\n\n\n\nTest de Pepe-Mori pour la variable surgery\n\n\nRisques\nChi2\nP&gt;Chi2\n\n\n\n\nCause1\n6.203\n0.0127\n\n\nCause2\n1.880\n0.7038\n\n\n\n\n\n\n\n\n\nR-Stata-Sas-Python\n\n\n\n\nSas: le test de Gray est estimé si on ajoute l’option strata=nom_variable à la proc lifetest sous risque concurrent (voir encadré précédent). Le test de Pepe-Mori est disponible via une macro externe (%compcif: non testée) :\nStata: Le test de Gray n’est pas disponible, il faut passer par une exécution de la fonction cuminc de la librairie R cmprsk directement dans stata (voir la commande rsource). Pour faire plus simple, on peut estimer le modèle de Fine-Gray avec une seule variable (discrète). Le résultat est comparable à celui du test (voir plus bas). Le test de Pepe-Mori est disponible via la commande externe stpepemori.\nR: On ajoute une variable à la fonction cuminc de la librairie cmprsk. Pas de test de Pepe-Mori sur les fonctions d’incidence à ma connaissance.\nPython: ne pas essayer d’utiliser la librairie cmprsk qui n’est pas mis à jour et ne fonctionne plus."
  },
  {
    "objectID": "11-concurrent.html#modèles",
    "href": "11-concurrent.html#modèles",
    "title": "12  Risques concurrents",
    "section": "12.4 Modèles",
    "text": "12.4 Modèles\n\n12.4.1 Modèles Semi paramétriques\nCette présentation sera plutôt brève. Dans le domaine des sciences sociales, je préconise plutôt l’utilisation d’un modèle multinomial à temps discret de type logistique. Le modèle de Cox en présence de risques concurrent n’est valable que dans une logique de risques « cause-specific », le modèle de Fine et Gray bien que directement relié à l’estimation des incidences cumulées, repose sur une définition du risque (de sous répartition) dont l’interprétation n’est pas naturelle. Il est également soumis à l’hypothèse de proportionnalité des risques.\nModélisation des risques « cause-specific » : Cox\nModèle de Cox «standard» pour chaque évènement, les évènements concurrents sont traités comme des censures à droite. Aucune interprétation sur les fonctions d’incidence ne peut-être faite.\nModèle de Fine-Gray: subdistribution hazard regression\nModèle de type semi-paramétrique avec une redéfinition du risque lié à l’estimation des fonctions d’incidence (voir test de Gray). La différence avec le Cox classique réside dans le calcul du risk-set : les évènements concurrents ne sont pas considérés comme des censures, on laisse les individus leur « survivre » jusqu’à la durée maximale observée dans l’échantillon. L’interprétation n’est donc pas très intuitive (Fine et Gray le soulignent). Ce modèle est relativement contreversé. Il ne sera donc pas exécuté pour l’application\n\nPour les questions liées à l’interprétation de ces deux types de modèles, se reporter à: https://onlinelibrary.wiley.com/doi/epdf/10.1002/sim.7501\n\n\n\n\n\n\nR-Stata-Sas-Python\n\n\n\n\nR: on utilise la fonction crr du package cmprsk.\nSas: même principe que pour l’estimation non paramétrique, on ajoute l’option eventcode=valeur à l’instruction model de la proc phreg.\nStata: on utilise la commande interne stcrreg.\nPython : ne pas essayer d’utiliser la librairie cmprsk qui n’est pas mis à jour et ne fonctionne donc plus.\n\n\n\n\n\n12.4.2 Modèle à temps discret\n\nIl s’agit d’une extension du modèle à temps discret à évènement unique (toutes causes regroupées) avec ici le modèle logistique multinomial.\nS’il ne permet pas une interprétation sur les fonctions d’incidences, les risques concurrents ne sont pas traitées comme des censures à droite.\nLe modèle multinomial repose sur une hypothèse dite « d’indépendance des alternatives non pertinentes » (IIA). Cela peut donc paraitre contradictoire d’utiliser ce modèle pour des évènements qui sont supposés non indépendants. Néanmoins la dépendance entre risques concurrents n’est pas non plus stricte et cette hypothèse d’IIA, seulement testable par le bon sens, est souvent illustrée par l’exemple des couleurs des bus dans le choix du mode de transport, ou les couleurs de chaussure dans les études marketing. Soit est une situation relativement limite.\nEn terme de lecture, les estiupateurs du modèle logistique multinomial peuvent directement s’interpréter comme des rapports de risque (ou relative risk ratio).\nEn sciences sociales, il me semble que ce type de modèle soit à privilégier.\nOn peut également envisager un modèle de type probit multinomial, mais on peut rencontrer des problèmes d’estimations (repose sur la loi normale multivariée). Prévoir un regroupement des causes concurrentes, et dans tous les cas de figure ne pas dépasser trois causes.\nNiveau lecture, on peut utiliser une méthode de standardisation, de type AME (Average Marginal Effect).\n\nPour l’application, nous avons pris le mois (30 jours) comme métrique temporelle. On rappelle que les valeurs des estimateurs sont fictives en raison de la simulation des évènement pour le risque concurrent (cause2)\n\n\nTable 12.1: Modèle logistique multinomial avec risques concurrent\n\n\n\n\n(a) Cause 1\n\n\nCause 1\nRRR\np&gt;|z|\n95% IC\n\n\n\n\n\\(t\\)\n0.816\n0.000\n0.752 - 0.885\n\n\n\\(t^2\\)\n1.003\n0.000\n1.001 - 1.005\n\n\n\\(year\\)\n0.879\n0.116\n0.749 - 1.032\n\n\n\\(age\\)\n1.045\n0.012\n1.010 - 1.081\n\n\n\\(surgery\\)\n0.318\n0.033\n0.110 - 0.913\n\n\n\\(constante\\)\n0.231\n0.000\n0.148 - 0.360\n\n\n\n\n\n\n(b) Cause 2\n\n\nCause 2\nRRR\np&gt;|z|\n95% IC\n\n\n\n\n\\(t\\)\n0.817\n0.003\n0.713 - 0.935\n\n\n\\(t^2\\)\n1.003\n0.052\n1.000 - 1.006\n\n\n\\(year\\)\n0.816\n0.141\n0.622 - 1.070\n\n\n\\(age\\)\n1.011\n0.654\n0.964 - 1.061\n\n\n\\(surgery\\)\n0.541\n0.431\n0.117 - 2.496\n\n\n\\(constante\\)\n0.076\n0.000\n0.037 - 0.157\n\n\n\n\n\n\nNotes:\n\nOn a utilisé le terme RRR - Relative Risk Ratio - pour la colonne raportant les estimations. Dans un cadre de risque concurrent il est un peu difficile d’utiliser formellement la notion de hazard rate tel qu’il a été difini plus haut, enfin les modèles multinomiaux ne reportent pas formellement des Odds Ratios dont l’utilisation devrait être réservé exclusivement à une alternative binaire.\nles variables year et age ont été centrées sur leur valeur moyenne pour donner aux constantes des valeurs acceptables.\nPour faciliter la lecture on peut utiliser une méthode de standardisation de type AME (Average Marginal Effect)."
  },
  {
    "objectID": "01-presentation.html#questions",
    "href": "01-presentation.html#questions",
    "title": "2  L’analyse biographique des durées",
    "section": "2.1 Questions",
    "text": "2.1 Questions\nOn dispose de données dites “longitudinales”, et on cherche à appréhender l’occurence d’un évènement au sein d’une population. Les problématiques se basent sur les questions suivantes:\n\n\nObserve-t-on la survenue de l’évènement pour l’ensemble des individus?\nQuelle est la durée jusqu’à la survenue de l’évènement?\nQuels sont les facteurs qui favorisent la survenue de cet évènement? Facteurs fixes ou facteurs pouvant apparaitre/changer au cours de la période d’observation: variables dynamiques (TVC: Time Varying Covariate)"
  },
  {
    "objectID": "01-presentation.html#terminologies",
    "href": "01-presentation.html#terminologies",
    "title": "2  L’analyse biographique des durées",
    "section": "2.2 Terminologies",
    "text": "2.2 Terminologies\n\n\n\nFrançais\nAnglais\n\n\n\n\nAnalyse des durées\nDuration analysis\n\n\nAnalyse de survie/séjour\nSurvival analysis\n\n\nAnalyse de fiabilité\nFailure time data analysis\n\n\nAnalyse des transitions\nEvent-history analysis"
  },
  {
    "objectID": "01-presentation.html#exemples-danalyse",
    "href": "01-presentation.html#exemples-danalyse",
    "title": "2  L’analyse biographique des durées",
    "section": "2.3 Exemples d’analyse",
    "text": "2.3 Exemples d’analyse\n\nNuptialité, Mise en couple: cohabiter, décohabiter, se marier, Rompre une union …\nLogement: Changement de statut (locataire &lt;=&gt; propriétaire), mobilité résidentielle/migration …\nEmploi: Trouver un 1er emploi, changer d’emploi, entrée ou sortie du chômage …\nFécondité: Avoir un premier enfant, avoir un nouvel enfant …\nMortalité: Décéder après diagnostic, survivre après l’administration un traitement, rechute…"
  },
  {
    "objectID": "01-presentation.html#elements-nécessaire-à-lanalyse",
    "href": "01-presentation.html#elements-nécessaire-à-lanalyse",
    "title": "2  L’analyse biographique des durées",
    "section": "2.4 Elements nécessaire à l’analyse",
    "text": "2.4 Elements nécessaire à l’analyse\n\nUn processus temporel\n\nUne échelle de mesure ou métrique temprelle: minutes, heures, jours, mois, années….\nUne origine commune définissant un évènement de départ 1: naissance, mariage si on analyse la séparation, …..\nUne définition précise de l’évènement d’étude.\n\nUne durée entre le début et la fin de la période d’observation, si nécessaire avec la fin de la période d’exposition au risque. Cette durée doit être généralement calculée à l’aide des informations de datation.\n\nUne population soumise au risque de connaître l’évènement (Risk Set)\nDes variables explicatives ou covariables\n\nFixes: sexe/genre, génération, niveau de diplôme le plus élevé,……\nDynamiques (TVC: Time varying covariates): Mesurées à tout moment entre le début et la sortie de l’observation: statut matrimonial, taille du ménage, statut d’activité…"
  },
  {
    "objectID": "01-presentation.html#types-danalyses",
    "href": "01-presentation.html#types-danalyses",
    "title": "2  L’analyse biographique des durées",
    "section": "2.5 Types d’analyses",
    "text": "2.5 Types d’analyses\n[A faire]"
  },
  {
    "objectID": "01-presentation.html#footnotes",
    "href": "01-presentation.html#footnotes",
    "title": "2  L’analyse biographique des durées",
    "section": "",
    "text": "Attention, dans le cadre des données prospectives ou de suivi, cela ne peut pas être le moment de l’inclusion à la base données↩︎"
  }
]